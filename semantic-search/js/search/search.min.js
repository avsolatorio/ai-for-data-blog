var yr = Object.create; var Q = Object.defineProperty; var Or = Object.getOwnPropertyDescriptor; var jr = Object.getOwnPropertyNames; var wr = Object.getPrototypeOf, kr = Object.prototype.hasOwnProperty; var B = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports); var Nr = (r, e, a, t) => { if (e && typeof e == "object" || typeof e == "function") for (let n of jr(e)) !kr.call(r, n) && n !== a && Q(r, n, { get: () => e[n], enumerable: !(t = Or(e, n)) || t.enumerable }); return r }; var U = (r, e, a) => (a = r != null ? yr(wr(r)) : {}, Nr(e || !r || !r.__esModule ? Q(a, "default", { value: r, enumerable: !0 }) : a, r)); var Z = B((Dr, Y) => { var f = Object.create(null), Sr = function (r, e) { var a, t = e.length, n, o = r.length, s = []; for (n = 0; n < o; n += 1)for (a = 0; a < t; a += 1)s.push(r[n].concat(e[a])); return s }; f.array = Object.create(null); f.array.isArray = function (r) { return r != null && Object.prototype.toString.call(r) === "[object Array]" }; f.array.ascending = function (r, e) { return r > e ? 1 : r === e ? 0 : -1 }; f.array.descending = function (r, e) { return e > r ? 1 : e === r ? 0 : -1 }; f.array.ascendingOnKey = function (r, e) { return r[0] > e[0] ? 1 : r[0] === e[0] ? 0 : -1 }; f.array.descendingOnKey = function (r, e) { return e[0] > r[0] ? 1 : e[0] === r[0] ? 0 : -1 }; f.array.ascendingOnValue = function (r, e) { return r[1] > e[1] ? 1 : r[1] === e[1] ? 0 : -1 }; f.array.descendingOnValue = function (r, e) { return e[1] > r[1] ? 1 : e[1] === r[1] ? 0 : -1 }; f.array.ascendingOn = function (r, e) { return e ? function (a, t) { return a[r][e] > t[r][e] ? 1 : a[r][e] === t[r][e] ? 0 : -1 } : function (a, t) { return a[r] > t[r] ? 1 : a[r] === t[r] ? 0 : -1 } }; f.array.descendingOn = function (r, e) { return e ? function (a, t) { return t[r][e] > a[r][e] ? 1 : t[r][e] === a[r][e] ? 0 : -1 } : function (a, t) { return t[r] > a[r] ? 1 : t[r] === a[r] ? 0 : -1 } }; f.array.pluck = function (r, e, a) { var t, n; t = r.length; var o = e || 0, s = a || t; for (s > t && (s = t), n = new Array(s), t = 0; t < s; t += 1)n[t] = r[t][o]; return n }; f.array.product = function (r) { return r.reduce(Sr, [[]]) }; f.array.shuffle = function (r) { for (var e = r, a = e.length, t, n; a;)t = Math.floor(Math.random() * a), a -= 1, n = e[a], e[a] = e[t], e[t] = n; return e }; var X = Object.keys, Mr = Object.create; f.object = Object.create(null); f.object.isObject = function (r) { return !!(r && Object.prototype.toString.call(r) === "[object Object]") }; f.object.keys = function (r) { return X(r) }; f.object.size = function (r) { return X(r).length }; f.object.values = function (r) { for (var e = f.object.keys(r), a = e.length, t = new Array(a), n = 0; n < a; n += 1)t[n] = r[e[n]]; return t }; f.object.valueFreq = function (r) { for (var e = f.object.keys(r), a = e.length, t, n = Mr(null), o = 0; o < a; o += 1)t = r[e[o]], n[t] = 1 + (n[t] || 0); return n }; f.object.table = function (r, e) { for (var a = f.object.keys(r), t = a.length, n = new Array(t), o, s, d = 0; d < t; d += 1)o = a[d], s = r[o], typeof e == "function" && e(s), n[d] = [o, s]; return n }; f.validate = Object.create(null); f.validate.isObject = f.object.isObject; f.validate.isArray = f.array.isArray; f.validate.isFiniteInteger = function (r) { return typeof r == "number" && !isNaN(r) && isFinite(r) && r === Math.round(r) }; f.validate.isFiniteNumber = function (r) { return typeof r == "number" && !isNaN(r) && isFinite(r) }; f.validate.cross = function (r) { let e = "unknown"; var a = !1, t, n, o, s, d, v, k = Object.create(null), S = Object.create(null), q = function () { a = !1, t = Object.create(null), n = Object.create(null), o = Object.create(null), s = Object.create(null); for (let y = 0; y < v; y += 1) { let p = d[y]; k[p] = !0, t[p] = Object.create(null), n[p] = 0, o[p] = 0, s[p] = 0; for (let F = 0; F < v; F += 1) { let E = d[F]; t[p][E] = 0 } } }, m = function (y, p) { return p === e || !k[y] || !k[p] ? !1 : (p === y ? t[y][p] += 1 : t[p][y] += 1, a = !0, !0) }, M = function () { if (!a) return null; var y = Object.create(null), p = Object.create(null), F = Object.create(null), E, c, O, J, C = 0, V = 0, x = 0; for (O = 0; O < v; O += 1)for (c = d[O], J = 0; J < v; J += 1)E = d[J], c === E && (y[c] = t[c][E]), p[c] = t[c][E] + (p[c] || 0), F[c] = t[E][c] + (F[c] || 0); for (O = 0; O < v; O += 1)c = d[O], n[c] = +(y[c] / p[c]).toFixed(4), isNaN(n[c]) && (n[c] = 0), o[c] = +(y[c] / F[c]).toFixed(4), isNaN(o[c]) && (o[c] = 0), s[c] = +(2 * n[c] * o[c] / (n[c] + o[c])).toFixed(4), isNaN(s[c]) && (s[c] = 0); for (O = 0; O < v; O += 1)C += n[d[O]] / v, V += o[d[O]] / v, x += s[d[O]] / v; return { avgPrecision: +C.toFixed(4), avgRecall: +V.toFixed(4), avgFMeasure: +x.toFixed(4), details: { confusionMatrix: t, precision: n, recall: o, fmeasure: s } } }; if (!f.validate.isArray(r)) throw Error("cross validate: class labels must be an array."); if (r.length < 2) throw Error("cross validate: at least 2 class labels are required."); return d = r, v = d.length, q(), S.reset = q, S.evaluate = m, S.metrics = M, S }; f.string = Object.create(null); var Fr = /[\u0300-\u036f]/g; f.string.normalize = function (r) { return r.toLowerCase().normalize("NFD").replace(Fr, "") }; Y.exports = f }); var $ = B((Ir, _) => { var j = Z(), Er = function () { var r = [], e, a = Object.create(null), t = Object.create(null), n = Object.create(null), o = [], s = [], d = !1, v = !1, k = 0, S = 0, q = 0, m = null, M = Object.create(null), y = 0, p = function (i, u) { for (var l = i, b = a[u] && a[u].pTasks || r, w = a[u] && a[u].pTaskCount || e, g = 0; g < w; g += 1)l = b[g](l); return l }, F = function (i, u, l, b, w) { for (var g = p(u, w), h, N = 0, T = g.length; N < T; N += 1)h = g[N], M[h] === void 0 && (M[h] = y, y += 1), h = M[h], b[h] === void 0 ? (b[h] = l, o[h] = o[h] || [], o[h].push(i)) : b[h] += l; return g.length * Math.abs(l) }, E = function (i, u) { if (m === null) throw Error("winkBM25S: Config must be defined before defining prepTasks."); if (!j.array.isArray(i)) throw Error("winkBM25S: Tasks should be an array, instead found: " + JSON.stringify(i)); for (var l = 0, b = i.length; l < b; l += 1)if (typeof i[l] != "function") throw Error("winkBM25S: Tasks should contain function, instead found: " + typeof i[l]); var w = m.fldWeights; if (u == null) r = i, e = i.length; else { if (!w[u] || typeof u != "string") throw Error("winkBM25S: Field name is missing or it is not a string: " + JSON.stringify(u) + "/" + typeof u); a[u] = a[u] || Object.create(null), a[u].pTasks = i, a[u].pTaskCount = i.length } return i.length }, c = function (i) { if (d) throw Error("winkBM25S: config must be defined before learning/addition starts!"); if (!j.object.isObject(i)) throw Error("winkBM25S: config must be a config object, instead found: " + JSON.stringify(i)); if (!j.object.isObject(i.fldWeights)) throw Error("winkBM25S: fldWeights must be an object, instead found: " + JSON.stringify(i.fldWeights)); if (j.object.keys(i.fldWeights).length === 0) throw Error("winkBM25S: Field config has no field defined."); m = Object.create(null), m.fldWeights = Object.create(null), m.bm25Params = Object.create(null), m.bm25Params.k1 = 1.2, m.bm25Params.b = .75, m.bm25Params.k = 1; for (var u in i.fldWeights) { if (!i.fldWeights[u] || isNaN(i.fldWeights[u])) throw Error("winkBM25S: Field weight should be number >0, instead found: " + JSON.stringify(i.fldWeights[u])); m.fldWeights[u] = +i.fldWeights[u] } if (j.object.isObject(i.bm25Params) || (i.bm25Params = Object.create(null)), m.bm25Params.b = i.bm25Params.b === null || i.bm25Params.b === void 0 || isNaN(i.bm25Params.b) || +i.bm25Params.b < 0 || +i.bm25Params.b > 1 ? .75 : +i.bm25Params.b, m.bm25Params.k1 = i.bm25Params.k1 === null || i.bm25Params.k1 === void 0 || isNaN(i.bm25Params.k1) || +i.bm25Params.k1 < 0 ? 1.2 : +i.bm25Params.k1, m.bm25Params.k = i.bm25Params.k === null || i.bm25Params.k === void 0 || isNaN(i.bm25Params.k) || +i.bm25Params.k < 0 ? 1 : +i.bm25Params.k, m.ovFldNames = [], i.ovFldNames || (i.ovFldNames = []), !j.array.isArray(i.ovFldNames)) throw Error("winkBM25S: OV Field names should be an array, instead found: " + JSON.stringify(typeof i.ovFldNames)); return i.ovFldNames.forEach(function (l) { if (typeof l != "string" || l.length === 0) throw Error("winkBM25S: OV Field name should be a non-empty string, instead found: " + JSON.stringify(l)); m.ovFldNames.push(l) }), !0 }, O = function (i, u) { if (m === null) throw Error("winkBM25S: Config must be defined before adding a document."); var l = m.fldWeights; if (v) throw Error("winkBM25S: post consolidation adding/learning is not possible!"); d = !0; var b; if (n[u] !== void 0) throw Error("winkBM25S: Duplicate document encountered: " + JSON.stringify(u)); n[u] = Object.create(null), n[u].freq = Object.create(null), n[u].fieldValues = Object.create(null), n[u].length = 0; for (var w in l) { if (i[w] === void 0) throw Error("winkBM25S: Missing field in the document: " + JSON.stringify(w)); b = F(u, i[w], l[w], n[u].freq, w), n[u].length += b, S += b } return m.ovFldNames.forEach(function (g) { if (i[g] === void 0) throw Error("winkBM25S: Missing field in the document: " + JSON.stringify(g)); n[u].fieldValues[g] = i[g] }), k += 1, k }, J = function () { return n }, C = function () { return M }, V = function () { return s }, x = function () { return m }, mr = function () { return S }, br = function () { return k }, hr = function (i) { if (v) throw Error("winkBM25S: consolidation can be carried out only once!"); if (k < 3) throw Error("winkBM25S: document collection is too small for consolidation; add more docs!"); var u = parseInt(i, 10); u = isNaN(u) || u < 4 ? 4 : u > 9 ? 9 : u; for (var l = m.bm25Params.b, b = m.bm25Params.k1, w = m.bm25Params.k, g, h, N, T, A, P = 0, W = o.length; P < W; P += 1)N = o[P].length, s[P] = Math.log((k - N + .5) / (N + .5) + w); q = S / k; for (h in n) { T = 1 - l + l * (n[h].length / q); for (A in n[h].freq) g = n[h].freq[A], n[h].freq[A] = Math.sign(g) * (Math.abs(g * (b + 1) / (b * T + g)) * s[A]).toFixed(u) } return v = !0, !0 }, R = function (i, u, l, b) { if (!v) throw Error("winkBM25S: search is not possible unless learnings are consolidated!"); if (typeof i != "string") throw Error("winkBM25S: search text should be a string, instead found: " + typeof i); var w = typeof l == "function" ? l : function () { return !0 }, g = p(i, "search").filter(function (K) { return M[K] !== void 0 }).map(function (K) { return M[K] }), h = Object.create(null), N, T, A, P, W, D, G; for (D = 0, G = g.length; D < G; D += 1)for (A = g[D], T = o[A], P = 0, W = T.length; P < W; P += 1)N = T[P], w(n[N].fieldValues, b) && (h[N] = n[N].freq[A] + (h[N] || 0)); return j.object.table(h).sort(j.array.descendingOnValue).slice(0, Math.max(u || 10, 1)) }, H = function () { return n = Object.create(null), o = [], s = [], d = !1, v = !1, k = 0, S = 0, q = 0, m = null, M = Object.create(null), y = 0, !0 }, gr = function () { var i = Object.create(null); return i.totalCorpusLength = S, i.totalDocs = k, i.consolidated = v, JSON.stringify([m, i, n, o, y, M, {}, [], []]) }, pr = function (i) { if (!i) throw Error("winkBM25S: undefined or null JSON encountered, import failed!"); var u = [j.object.isObject, j.object.isObject, j.object.isObject, j.array.isArray, Number.isInteger, j.object.isObject, j.object.isObject, j.array.isArray, j.array.isArray], l = JSON.parse(i); if (!j.array.isArray(l) || l.length !== u.length) throw Error("winkBM25S: invalid JSON encountered, can not import."); for (var b = 0; b < u.length; b += 1)if (!u[b](l[b])) throw Error("winkBM25S: invalid JSON encountered, can not import."); return H(), d = !0, m = l[0], S = l[1].totalCorpusLength, k = l[1].totalDocs, v = l[1].consolidated, n = l[2], o = l[3], y = l[4], M = l[5], !0 }; return t.definePrepTasks = E, t.defineConfig = c, t.addDoc = O, t.getDocs = J, t.getTokens = C, t.getConfig = x, t.getIDF = V, t.getTotalCorpusLength = mr, t.getTotalDocs = br, t.consolidate = hr, t.search = R, t.exportJSON = gr, t.importJSON = pr, t.reset = H, t.learn = O, t.predict = R, t }; _.exports = Er }); var I = B((Lr, rr) => { "use strict"; function Pr(r) { return Object.prototype.toString.call(r) === "[object Array]" } rr.exports = Array.isArray || Pr }); var L = B((zr, er) => { "use strict"; function Tr(r) { return typeof r == "function" } er.exports = Tr }); var ar = B((Kr, nr) => { "use strict"; var tr = I(), Ar = L(); function Br(r, e, a) { if (!tr(r)) throw new TypeError("dot()::invalid input argument. First argument must be an array. Value: `" + r + "`."); if (!tr(e)) throw new TypeError("dot()::invalid input argument. Second argument must be an array. Value: `" + e + "`."); if (arguments.length > 2 && !Ar(a)) throw new TypeError("dot()::invalid input argument. Accessor must be a function. Value: `" + a + "`."); var t = r.length, n = 0, o; if (t !== e.length) throw new Error("dot()::invalid input argument. Arrays must be of equal length."); if (!t) return null; if (a) for (o = 0; o < t; o++)n += a(r[o], o, 0) * a(e[o], o, 1); else for (o = 0; o < t; o++)n += r[o] * e[o]; return n } nr.exports = Br }); var or = B((Rr, ir) => { "use strict"; var qr = I(), Jr = L(); function Cr(r, e) { if (!qr(r)) throw new TypeError("l2norm()::invalid input argument. Must provide an array.  Value: `" + r + "`."); if (arguments.length > 1 && !Jr(e)) throw new TypeError("l2norm()::invalid input argument. Accessor must be a function. Value: `" + e + "`."); var a = r.length, t = 0, n = 1, o, s, d, v; if (!a) return null; if (e) for (v = 0; v < a; v++)s = e(r[v], v), d = s < 0 ? -s : s, d > 0 && (d > t ? (o = t / s, n = 1 + n * o * o, t = d) : (o = s / t, n = n + o * o)); else for (v = 0; v < a; v++)s = r[v], d = s < 0 ? -s : s, d > 0 && (d > t ? (o = t / s, n = 1 + n * o * o, t = d) : (o = s / t, n = n + o * o)); return t * Math.sqrt(n) } ir.exports = Cr }); var cr = B((Hr, fr) => { "use strict"; var ur = ar(), z = or(), lr = I(), Vr = L(); function sr(r, e) { return function (t, n) { return r(t, n, e) } } function xr(r, e, a) { var t, n, o; if (!lr(r)) throw new TypeError("cosine-similarity()::invalid input argument. First argument must be an array. Value: `" + r + "`."); if (!lr(e)) throw new TypeError("cosine-similarity()::invalid input argument. Second argument must be an array. Value: `" + e + "`."); if (arguments.length > 2 && !Vr(a)) throw new TypeError("cosine-similarity()::invalid input argument. Accessor must be a function. Value: `" + a + "`."); if (r.length !== e.length) throw new Error("cosine-similarity()::invalid input argument. Input arrays must have the same length."); return r.length ? (a ? (t = ur(r, e, a), n = z(r, sr(a, 0)), o = z(e, sr(a, 1))) : (t = ur(r, e), n = z(r), o = z(e)), t / (n * o)) : null } fr.exports = xr }); var dr = U($()), vr = U(cr()); console.log("Hello similarity..."); console.log(vr.default); console.log("Hello bm25..."); console.log(dr.default); var export_bm25 = dr.default; var export_similarity = vr.default; export { export_bm25 as bm25, export_similarity as similarity };
