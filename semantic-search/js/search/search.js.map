{"mappings":"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","sources":["<anon>","search/search.js","node_modules/wink-bm25-text-search/src/wink-bm25-text-search.js","node_modules/wink-helpers/src/wink-helpers.js","node_modules/compute-cosine-similarity/lib/index.js","node_modules/compute-dot/lib/index.js","node_modules/validate.io-array/lib/index.js","node_modules/validate.io-function/lib/index.js","node_modules/compute-l2norm/lib/index.js"],"sourcesContent":["(() => {\nvar $677849fcdd97ee5d$exports = {};\n//     wink-bm25-text-search\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-bm25-text-search”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n//\nvar $3de00a38380ef818$exports = {};\n//     wink-helpers\n//     Functions for cross validation, shuffle, cartesian product and more\n//\n//     Copyright (C) 2017-18  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-helpers”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n//\nvar $3de00a38380ef818$var$helpers = Object.create(null);\n// ### Private Functions\n// #### Product Reducer (Callback)\n// Callback function used by `reduce` inside the `product()` function.\n// Follows the standard guidelines of `reduce()` callback function.\nvar $3de00a38380ef818$var$productReducer = function(prev, curr) {\n    var c, cmax = curr.length;\n    var p, pmax = prev.length;\n    var result = [];\n    for(p = 0; p < pmax; p += 1)for(c = 0; c < cmax; c += 1)result.push(prev[p].concat(curr[c]));\n    return result;\n}; // productReducer()\n// ### Public Function\n// ### Array Helpers\n$3de00a38380ef818$var$helpers.array = Object.create(null);\n// #### is Array\n// Tests if argument `v` is a JS array; returns `true` if it is, otherwise returns `false`.\n$3de00a38380ef818$var$helpers.array.isArray = function(v) {\n    return v !== undefined && v !== null && Object.prototype.toString.call(v) === \"[object Array]\";\n}; // isArray()\n// #### sorting helpers\n// Set of helpers to sort either numbers or strings. For key/value pairs,\n// the format for each element must be `[ key, value ]`.\n// Sort helper to sort an array in ascending order.\n$3de00a38380ef818$var$helpers.array.ascending = function(a, b) {\n    return a > b ? 1 : a === b ? 0 : -1;\n}; // ascending()\n// Sort helper to sort an array in descending order.\n$3de00a38380ef818$var$helpers.array.descending = function(a, b) {\n    return b > a ? 1 : b === a ? 0 : -1;\n}; // descending()\n// Sort helper to sort an array of `[ key, value ]` in ascending order by **key**.\n$3de00a38380ef818$var$helpers.array.ascendingOnKey = function(a, b) {\n    return a[0] > b[0] ? 1 : a[0] === b[0] ? 0 : -1;\n}; // ascendingOnKey()\n// Sort helper to sort an array of `[ key, value ]` in descending order by **key**.\n$3de00a38380ef818$var$helpers.array.descendingOnKey = function(a, b) {\n    return b[0] > a[0] ? 1 : b[0] === a[0] ? 0 : -1;\n}; // descendingOnKey()\n// Sort helper to sort an array of `[ key, value ]` in ascending order by **value**.\n$3de00a38380ef818$var$helpers.array.ascendingOnValue = function(a, b) {\n    return a[1] > b[1] ? 1 : a[1] === b[1] ? 0 : -1;\n}; // ascendingOnValue()\n// Sort helper to sort an array of `[ key, value ]` in descending order by **value**.\n$3de00a38380ef818$var$helpers.array.descendingOnValue = function(a, b) {\n    return b[1] > a[1] ? 1 : b[1] === a[1] ? 0 : -1;\n}; // descendingOnValue()\n// The following two functions generate a suitable function for sorting on a single\n// key or on a composite keys (max 2 only). Just a remider, the generated function\n// does not sort on two keys; instead it will sort on a key composed of the two\n// accessors.\n// Sorts in ascending order on `accessor1` & `accessor2` (optional).\n$3de00a38380ef818$var$helpers.array.ascendingOn = function(accessor1, accessor2) {\n    if (accessor2) return function(a, b) {\n        return a[accessor1][accessor2] > b[accessor1][accessor2] ? 1 : a[accessor1][accessor2] === b[accessor1][accessor2] ? 0 : -1;\n    };\n    return function(a, b) {\n        return a[accessor1] > b[accessor1] ? 1 : a[accessor1] === b[accessor1] ? 0 : -1;\n    };\n}; // ascendingOn()\n// Sorts in descending order on `accessor1` & `accessor2` (optional).\n$3de00a38380ef818$var$helpers.array.descendingOn = function(accessor1, accessor2) {\n    if (accessor2) return function(a, b) {\n        return b[accessor1][accessor2] > a[accessor1][accessor2] ? 1 : b[accessor1][accessor2] === a[accessor1][accessor2] ? 0 : -1;\n    };\n    return function(a, b) {\n        return b[accessor1] > a[accessor1] ? 1 : b[accessor1] === a[accessor1] ? 0 : -1;\n    };\n}; // descendingOn()\n// #### pluck\n// Plucks specified element from each element of an **array of array**, and\n// returns the resultant array. The element is specified by `i` (default `0`) and\n// number of elements to pluck are defined by `limit` (default `a.length`).\n$3de00a38380ef818$var$helpers.array.pluck = function(a, key, limit) {\n    var k, plucked;\n    k = a.length;\n    var i = key || 0;\n    var lim = limit || k;\n    if (lim > k) lim = k;\n    plucked = new Array(lim);\n    for(k = 0; k < lim; k += 1)plucked[k] = a[k][i];\n    return plucked;\n}; // pluck()\n// #### product\n// Finds the Cartesian Product of arrays present inside the array `a`. Therefore\n// the array `a` must be an array of 1-dimensional arrays. For example,\n// `product( [ [ 9, 8 ], [ 1, 2 ] ] )`\n// will produce `[ [ 9, 1 ], [ 9, 2 ], [ 8, 1 ], [ 8, 2 ] ]`.\n$3de00a38380ef818$var$helpers.array.product = function(a) {\n    return a.reduce($3de00a38380ef818$var$productReducer, [\n        []\n    ]);\n};\n// #### shuffle\n// Randomly shuffles the elements of an array and returns the same.\n// Reference: Chapter on Random Numbers/Shuffling in Seminumerical algorithms.\n// The Art of Computer Programming Volume II by Donald E Kunth\n$3de00a38380ef818$var$helpers.array.shuffle = function(array) {\n    var a = array;\n    var balance = a.length;\n    var candidate;\n    var temp;\n    while(balance){\n        candidate = Math.floor(Math.random() * balance);\n        balance -= 1;\n        temp = a[balance];\n        a[balance] = a[candidate];\n        a[candidate] = temp;\n    }\n    return a;\n};\n// ### Object Helpers\nvar $3de00a38380ef818$var$objectKeys = Object.keys;\nvar $3de00a38380ef818$var$objectCreate = Object.create;\n$3de00a38380ef818$var$helpers.object = Object.create(null);\n// #### is Object\n// Tests if argument `v` is a JS object; returns `true` if it is, otherwise returns `false`.\n$3de00a38380ef818$var$helpers.object.isObject = function(v) {\n    return v && Object.prototype.toString.call(v) === \"[object Object]\" ? true : false; // eslint-disable-line no-unneeded-ternary\n}; // isObject()\n// #### keys\n// Returns keys of the `obj` in an array.\n$3de00a38380ef818$var$helpers.object.keys = function(obj) {\n    return $3de00a38380ef818$var$objectKeys(obj);\n}; // keys()\n// #### size\n// Returns the number of keys of the `obj`.\n$3de00a38380ef818$var$helpers.object.size = function(obj) {\n    return $3de00a38380ef818$var$objectKeys(obj).length;\n}; // size()\n// #### values\n// Returns all values from each key/value pair of the `obj` in an array.\n$3de00a38380ef818$var$helpers.object.values = function(obj) {\n    var keys = $3de00a38380ef818$var$helpers.object.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for(var i = 0; i < length; i += 1)values[i] = obj[keys[i]];\n    return values;\n}; // values()\n// #### value Freq\n// Returns the frequency of each unique value present in the `obj`, where the\n// **key** is the *value* and **value** is the *frequency*.\n$3de00a38380ef818$var$helpers.object.valueFreq = function(obj) {\n    var keys = $3de00a38380ef818$var$helpers.object.keys(obj);\n    var length = keys.length;\n    var val;\n    var vf = $3de00a38380ef818$var$objectCreate(null);\n    for(var i = 0; i < length; i += 1){\n        val = obj[keys[i]];\n        vf[val] = 1 + (vf[val] || 0);\n    }\n    return vf;\n}; // valueFreq()\n// #### table\n// Converts the `obj` in to an array of `[ key, value ]` pairs in form of a table.\n// Second argument - `f` is optional and it is a function, which is called with\n// each `value`.\n$3de00a38380ef818$var$helpers.object.table = function(obj, f) {\n    var keys = $3de00a38380ef818$var$helpers.object.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    var ak, av;\n    for(var i = 0; i < length; i += 1){\n        ak = keys[i];\n        av = obj[ak];\n        if (typeof f === \"function\") f(av);\n        pairs[i] = [\n            ak,\n            av\n        ];\n    }\n    return pairs;\n}; // table()\n// ### Validation Helpers\n$3de00a38380ef818$var$helpers.validate = Object.create(null);\n// Create aliases for isObject and isArray.\n$3de00a38380ef818$var$helpers.validate.isObject = $3de00a38380ef818$var$helpers.object.isObject;\n$3de00a38380ef818$var$helpers.validate.isArray = $3de00a38380ef818$var$helpers.array.isArray;\n// #### isFiniteInteger\n// Validates if `n` is a finite integer.\n$3de00a38380ef818$var$helpers.validate.isFiniteInteger = function(n) {\n    return typeof n === \"number\" && !isNaN(n) && isFinite(n) && n === Math.round(n);\n}; // isFiniteInteger()\n// #### isFiniteNumber\n// Validates if `n` is a valid number.\n$3de00a38380ef818$var$helpers.validate.isFiniteNumber = function(n) {\n    return typeof n === \"number\" && !isNaN(n) && isFinite(n);\n}; // isFiniteNumber()\n// ### cross validation\n/**\n *\n * Creates an instance of cross validator useful for machine learning tasks.\n *\n * @param {string[]} classLabels - array containing all the class labels.\n * @return {methods} object conatining set of API methods for tasks like evalutaion,\n * reset and metrics generation.\n*/ $3de00a38380ef818$var$helpers.validate.cross = function(classLabels) {\n    // wink's const for unknown predictions!\n    const unknown = \"unknown\";\n    // To ensure that metrics is not computed prior to evaluation.\n    var evaluated = false;\n    // The confusion matrix.\n    var cm;\n    var precision;\n    var recall;\n    var fmeasure;\n    // The class labels is assigned to this variable.\n    var labels;\n    // The length of `labels` array.\n    var labelCount;\n    var labelsObj = Object.create(null);\n    // Returned!\n    var methods = Object.create(null);\n    /**\n   *\n   * Resets the current instance for another round of evaluation; the class\n   * labels defined at instance creation time are not touched.\n   *\n   * @return {undefined} nothing!\n  */ var reset = function() {\n        evaluated = false;\n        cm = Object.create(null);\n        precision = Object.create(null);\n        recall = Object.create(null);\n        fmeasure = Object.create(null);\n        // Initialize confusion matrix and metrics.\n        for(let i = 0; i < labelCount; i += 1){\n            const row = labels[i];\n            labelsObj[row] = true;\n            cm[row] = Object.create(null);\n            precision[row] = 0;\n            recall[row] = 0;\n            fmeasure[row] = 0;\n            for(let j = 0; j < labelCount; j += 1){\n                const col = labels[j];\n                cm[row][col] = 0;\n            }\n        }\n    }; // reset()\n    /**\n   *\n   * Creates an instance of cross validator useful for machine learning tasks.\n   *\n   * @param {string} truth - the actual class label.\n   * @param {string} guess - the predicted class label.\n   * @return {boolean} returns true if the evaluation is successful. The evaluation\n   * may fail if `truth` or `guess` is not in the array `classLabels` provided at\n   * instance creation time; or if guess is equal to `unknown`.\n  */ var evaluate = function(truth, guess) {\n        // If prediction failed then return false!\n        if (guess === unknown || !labelsObj[truth] || !labelsObj[guess]) return false;\n        // Update confusion matrix.\n        if (guess === truth) cm[truth][guess] += 1;\n        else cm[guess][truth] += 1;\n        evaluated = true;\n        return true;\n    }; // evaluate()\n    /**\n   *\n   * It computes a detailed metrics consisting of macro-averaged precision,\n   * recall and f-measure along with their label-wise values and the confusion\n   * matrix.\n   *\n   * @return {object} object containing macro-averaged `avgPrecision`, `avgRecall`,\n   * `avgFMeasure` values along with other details such as label-wise values\n   * and the confusion matrix. A value of `null` is returned if no evaluate()\n   * has been called before.\n  */ var metrics = function() {\n        if (!evaluated) return null;\n        // Numerators for every label; they are same for precision & recall both.\n        var n = Object.create(null);\n        // Only denominators differs for precision & recall\n        var pd = Object.create(null);\n        var rd = Object.create(null);\n        // `row` and `col` of confusion matrix.\n        var col, row;\n        var i, j;\n        // Macro average values for metrics.\n        var avgPrecision = 0;\n        var avgRecall = 0;\n        var avgFMeasure = 0;\n        // Compute label-wise numerators & denominators!\n        for(i = 0; i < labelCount; i += 1){\n            row = labels[i];\n            for(j = 0; j < labelCount; j += 1){\n                col = labels[j];\n                if (row === col) n[row] = cm[row][col];\n                pd[row] = cm[row][col] + (pd[row] || 0);\n                rd[row] = cm[col][row] + (rd[row] || 0);\n            }\n        }\n        // Ready to compute metrics.\n        for(i = 0; i < labelCount; i += 1){\n            row = labels[i];\n            precision[row] = +(n[row] / pd[row]).toFixed(4);\n            // NaN can occur if a label has not been encountered.\n            if (isNaN(precision[row])) precision[row] = 0;\n            recall[row] = +(n[row] / rd[row]).toFixed(4);\n            if (isNaN(recall[row])) recall[row] = 0;\n            fmeasure[row] = +(2 * precision[row] * recall[row] / (precision[row] + recall[row])).toFixed(4);\n            if (isNaN(fmeasure[row])) fmeasure[row] = 0;\n        }\n        // Compute thier averages, note they will be macro avegages.\n        for(i = 0; i < labelCount; i += 1){\n            avgPrecision += precision[labels[i]] / labelCount;\n            avgRecall += recall[labels[i]] / labelCount;\n            avgFMeasure += fmeasure[labels[i]] / labelCount;\n        }\n        // Return metrics.\n        return {\n            // Macro-averaged metrics.\n            avgPrecision: +avgPrecision.toFixed(4),\n            avgRecall: +avgRecall.toFixed(4),\n            avgFMeasure: +avgFMeasure.toFixed(4),\n            details: {\n                // Confusion Matrix.\n                confusionMatrix: cm,\n                // Label wise metrics details, from those averages were computed.\n                precision: precision,\n                recall: recall,\n                fmeasure: fmeasure\n            }\n        };\n    }; // metrics()\n    if (!$3de00a38380ef818$var$helpers.validate.isArray(classLabels)) throw Error(\"cross validate: class labels must be an array.\");\n    if (classLabels.length < 2) throw Error(\"cross validate: at least 2 class labels are required.\");\n    labels = classLabels;\n    labelCount = labels.length;\n    reset();\n    methods.reset = reset;\n    methods.evaluate = evaluate;\n    methods.metrics = metrics;\n    return methods;\n}; // cross()\n// ### Object Helpers\n$3de00a38380ef818$var$helpers.string = Object.create(null);\n// Regex for [diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) removal.\nvar $3de00a38380ef818$var$rgxDiacritical = /[\\u0300-\\u036f]/g;\n/**\n *\n * Normalizes the token's value by converting it to lower case and stripping\n * the diacritical marks (if any).\n *\n * @param {string} str — that needs to be normalized.\n * @return {string} the normalized value.\n * @example\n * normalize( 'Nestlé' );\n * // -> nestle\n*/ $3de00a38380ef818$var$helpers.string.normalize = function(str) {\n    return str.toLowerCase().normalize(\"NFD\").replace($3de00a38380ef818$var$rgxDiacritical, \"\");\n}; // normalize()\n$3de00a38380ef818$exports = $3de00a38380ef818$var$helpers;\n\n\n/* eslint guard-for-in: 0 */ /* eslint complexity: [ \"error\", 25 ] */ // It is a BM25F In-memory Search engine for text and exposes following\n// methods:\n// 1. `definePrepTasks` allows to define field-wise (optional) pipeline of\n// functions that will be used to prepare each input prior to *search/predict*\n// and *addDoc/learn*.\n// 2. `defineConfig` sets up the configuration for *field-wise weights*,\n// *BM25F parameters*, and **field names whoes original value** needs to be retained.\n// 3. `addDoc/learn` adds a document using its unique id. The document is supplied\n// as an Javascript object, where each property is the field of the document\n// and its value is the text.\n// 4. `consolidate` learnings prior to search/predict.\n// 5. `search/predict` searches for the input text and returns the resultant\n// document ids, sorted by their relevance along with the score. The number of\n// results returned can be controlled via a limit argument that defaults to **10**.\n// The last optional argument is a filter function that must return a `boolean`\n// value, which is used to filter documents.\n// 6. `exportJSON` exports the learnings in JSON format.\n// 7. `importJSON` imports the learnings from JSON that may have been saved on disk.\n// 8. `reset` all the learnings except the preparatory tasks.\nvar $677849fcdd97ee5d$var$bm25fIMS = function() {\n    // Preparatory tasks that are executed on the `addDoc` & `search` input.\n    var pTasks = [];\n    // And its count.\n    var pTaskCount;\n    // Field level prep tasks.\n    var flds = Object.create(null);\n    // Returned!\n    var methods = Object.create(null);\n    // Term Frequencies & length of each document.\n    var documents = Object.create(null);\n    // Inverted Index for faster search\n    var invertedIdx = [];\n    // IDF for each tokens, tokens are referenced via their numerical index.\n    var idf = [];\n    // Set true on first call to `addDoc/learn` to prevent changing config.\n    var learned = false;\n    // The `addDoc()predict()` function checks for this being true; set\n    // in `consolidate()`.\n    var consolidated = false;\n    // Total documents added.\n    var totalDocs = 0;\n    // Total number of tokens across all documents added.\n    var totalCorpusLength = 0;\n    // Their average.\n    var avgCorpusLength = 0;\n    // BM25F Configuration; set up in `defineConfig()`.\n    var config = null;\n    // The `token: index` mapping; `index` is used everywhere instead\n    // of the `token`\n    var token2Index = Object.create(null);\n    // Index's initial value, incremented with every new word.\n    var currTokenIndex = 0;\n    // ### Private functions\n    // #### Perpare Input\n    // Prepares the `input` by executing the pipeline of tasks defined in the\n    // `field` specific `pTasks` set via `definePrepTasks()`.\n    // If `field` is not specified then default `pTasks` are used.\n    // If the `field` specific `pTasks` are not defined then it automatically\n    // switches to default `pTasks`.\n    var prepareInput = function(input, field) {\n        var processedInput = input;\n        var pt = flds[field] && flds[field].pTasks || pTasks;\n        var ptc = flds[field] && flds[field].pTaskCount || pTaskCount;\n        for(var i = 0; i < ptc; i += 1)processedInput = pt[i](processedInput);\n        return processedInput;\n    }; // prepareInput()\n    // #### Update Freq\n    // Updates the `freq` of each term in the `text` after pre-processing it via\n    // `prepareInput()`; while updating, it takes care of `field's` `weight`.\n    var updateFreq = function(id, text, weight, freq, field) {\n        // Tokenized `text`.\n        var tkns = prepareInput(text, field);\n        // Temp token holder.\n        var t;\n        for(var i = 0, imax = tkns.length; i < imax; i += 1){\n            t = tkns[i];\n            // Build `token: index` mapping.\n            if (token2Index[t] === undefined) {\n                token2Index[t] = currTokenIndex;\n                currTokenIndex += 1;\n            }\n            t = token2Index[t];\n            if (freq[t] === undefined) {\n                freq[t] = weight;\n                invertedIdx[t] = invertedIdx[t] || [];\n                invertedIdx[t].push(id);\n            } else freq[t] += weight;\n        }\n        // Length can not be negative!\n        return tkns.length * Math.abs(weight);\n    }; // updateFreq()\n    // ### Exposed Functions\n    // #### Define Prep Tasks\n    // Defines the `tasks` required to prepare the input for `addDoc` and `search()`\n    // The `tasks` should be an array of functions; using these function a simple\n    // pipeline is built to serially transform the input to the output.\n    // It validates the `tasks` before updating the `pTasks`.\n    // If validation fails it throws an appropriate error.\n    // Tasks can be defined separately for each field. However if the field is not\n    // specified (i.e. `null` or `undefined`), then the `tasks` become default.\n    // Note, `field = 'search'` is reserved for prep tasks for search string; However\n    // if the same is not specified, the default tasks are used for pre-processing.\n    var definePrepTasks = function(tasks, field) {\n        if (config === null) throw Error(\"winkBM25S: Config must be defined before defining prepTasks.\");\n        if (!$3de00a38380ef818$exports.array.isArray(tasks)) throw Error(\"winkBM25S: Tasks should be an array, instead found: \" + JSON.stringify(tasks));\n        for(var i = 0, imax = tasks.length; i < imax; i += 1){\n            if (typeof tasks[i] !== \"function\") throw Error(\"winkBM25S: Tasks should contain function, instead found: \" + typeof tasks[i]);\n        }\n        var fldWeights = config.fldWeights;\n        if (field === undefined || field === null) {\n            pTasks = tasks;\n            pTaskCount = tasks.length;\n        } else {\n            if (!fldWeights[field] || typeof field !== \"string\") throw Error(\"winkBM25S: Field name is missing or it is not a string: \" + JSON.stringify(field) + \"/\" + typeof field);\n            flds[field] = flds[field] || Object.create(null);\n            flds[field].pTasks = tasks;\n            flds[field].pTaskCount = tasks.length;\n        }\n        return tasks.length;\n    }; // definePrepTasks()\n    // #### Define Config\n    // Defines the configuration for BM25F using `fldWeights` and `bm25Params`\n    // properties of `cfg` object.</br>\n    // The `fldWeights` defines the weight for each field of the document. This gives\n    // a semantic nudge to search and are used as a mutiplier to the count\n    // (frequency) of each token contained in that field of the document. It should\n    // be a JS object containing `field-name/value` pairs. If a field's weight is\n    // not defined, that field is **ignored**. The field weights must be defined before\n    // attempting to add a document via `addDoc()`; they can only be defined once.\n    // If any document's field is not defined here then that field is **ignored**.\n    // </br>\n    // The `k`, `b` and `k1` properties of `bm25Params` object define the smoothing\n    // factor for IDF, degree of normalization for TF, and saturation control factor\n    // respectively for the BM25F. Their default values are **1**, **0.75**, and\n    // **1.2**.<br/>\n    // The `ovFieldNames` is an array of field names whose original value needs to\n    // be retained.\n    var defineConfig = function(cfg) {\n        if (learned) throw Error(\"winkBM25S: config must be defined before learning/addition starts!\");\n        if (!$3de00a38380ef818$exports.object.isObject(cfg)) throw Error(\"winkBM25S: config must be a config object, instead found: \" + JSON.stringify(cfg));\n        // If `fldWeights` are absent throw error.\n        if (!$3de00a38380ef818$exports.object.isObject(cfg.fldWeights)) throw Error(\"winkBM25S: fldWeights must be an object, instead found: \" + JSON.stringify(cfg.fldWeights));\n        // There should be at least one defined field!\n        if ($3de00a38380ef818$exports.object.keys(cfg.fldWeights).length === 0) throw Error(\"winkBM25S: Field config has no field defined.\");\n        // Setup configuration now.\n        config = Object.create(null);\n        // Field config for BM25**F**\n        config.fldWeights = Object.create(null);\n        config.bm25Params = Object.create(null);\n        // **Controls TF part:**<br/>\n        // `k1` controls saturation of token's frequency; higher value delays saturation\n        // with increase in frequency.\n        config.bm25Params.k1 = 1.2;\n        // `b` controls the degree of normalization; **0** means no normalization and **1**\n        // indicates complete normalization!\n        config.bm25Params.b = 0.75;\n        // **Controls IDF part:**<br/>\n        // `k` controls impact of IDF; should be >= 0; a higher value means lower\n        // the impact of IDF.\n        config.bm25Params.k = 1;\n        // Setup field weights.\n        for(var field in cfg.fldWeights){\n            // The `null` check is required as `isNaN( null )` returns `false`!!\n            // This first ensures non-`null/undefined/0` values before testing for NaN.\n            if (!cfg.fldWeights[field] || isNaN(cfg.fldWeights[field])) throw Error(\"winkBM25S: Field weight should be number >0, instead found: \" + JSON.stringify(cfg.fldWeights[field]));\n            // Update config parameters from `cfg`.\n            config.fldWeights[field] = +cfg.fldWeights[field];\n        }\n        // Setup BM25F params.\n        // Create `bm25Params` if absent in `cfg`.\n        if (!$3de00a38380ef818$exports.object.isObject(cfg.bm25Params)) cfg.bm25Params = Object.create(null);\n        // Update config parameters from `cfg`.\n        config.bm25Params.b = cfg.bm25Params.b === null || cfg.bm25Params.b === undefined || isNaN(cfg.bm25Params.b) || +cfg.bm25Params.b < 0 || +cfg.bm25Params.b > 1 ? 0.75 : +cfg.bm25Params.b;\n        // Update config parameters from `cfg`.\n        config.bm25Params.k1 = cfg.bm25Params.k1 === null || cfg.bm25Params.k1 === undefined || isNaN(cfg.bm25Params.k1) || +cfg.bm25Params.k1 < 0 ? 1.2 : +cfg.bm25Params.k1;\n        // Update config parameters from `cfg`.\n        config.bm25Params.k = cfg.bm25Params.k === null || cfg.bm25Params.k === undefined || isNaN(cfg.bm25Params.k) || +cfg.bm25Params.k < 0 ? 1 : +cfg.bm25Params.k;\n        // Handle configuration for fields whose orginal values has to be retained\n        // in the document.<br/>\n        // Initialize the `ovFldNames` in the final `config` as an empty array\n        config.ovFldNames = [];\n        if (!cfg.ovFldNames) cfg.ovFldNames = [];\n        if (!$3de00a38380ef818$exports.array.isArray(cfg.ovFldNames)) throw Error(\"winkBM25S: OV Field names should be an array, instead found: \" + JSON.stringify(typeof cfg.ovFldNames));\n        cfg.ovFldNames.forEach(function(f) {\n            if (typeof f !== \"string\" || f.length === 0) throw Error(\"winkBM25S: OV Field name should be a non-empty string, instead found: \" + JSON.stringify(f));\n            config.ovFldNames.push(f);\n        });\n        return true;\n    }; // defineConfig()\n    // #### Add Doc\n    // Adds a document to the model using `updateFreq()` function.\n    var addDoc = function(doc, id) {\n        if (config === null) throw Error(\"winkBM25S: Config must be defined before adding a document.\");\n        var fldWeights = config.fldWeights;\n        // No point in adding/learning further in absence of consolidated.\n        if (consolidated) throw Error(\"winkBM25S: post consolidation adding/learning is not possible!\");\n        // Set learning/addition started.\n        learned = true;\n        var length;\n        if (documents[id] !== undefined) throw Error(\"winkBM25S: Duplicate document encountered: \" + JSON.stringify(id));\n        documents[id] = Object.create(null);\n        documents[id].freq = Object.create(null);\n        documents[id].fieldValues = Object.create(null);\n        documents[id].length = 0;\n        // Compute `freq` & `length` of the specified fields.\n        for(var field in fldWeights){\n            if (doc[field] === undefined) throw Error(\"winkBM25S: Missing field in the document: \" + JSON.stringify(field));\n            length = updateFreq(id, doc[field], fldWeights[field], documents[id].freq, field);\n            documents[id].length += length;\n            totalCorpusLength += length;\n        }\n        // Retain Original Field Values, if configured.\n        config.ovFldNames.forEach(function(f) {\n            if (doc[f] === undefined) throw Error(\"winkBM25S: Missing field in the document: \" + JSON.stringify(f));\n            documents[id].fieldValues[f] = doc[f];\n        });\n        // Increment total documents indexed so far.\n        totalDocs += 1;\n        return totalDocs;\n    }; // addDoc()\n    // #### Get Docs\n    // Returns the document database.\n    var getDocs = function() {\n        return documents;\n    };\n    // #### Get Tokens\n    // Returns the token to token ID database.\n    var getTokens = function() {\n        return token2Index;\n    };\n    // #### Get IDF\n    // Returns token ID to IDF database.\n    var getIDF = function() {\n        return idf;\n    };\n    // #### Get Config\n    // Returns the config.\n    var getConfig = function() {\n        return config;\n    };\n    // #### Get TotalCorpusLength\n    // Returns the number of tokens in the database.\n    var getTotalCorpusLength = function() {\n        return totalCorpusLength;\n    };\n    // #### Get TotalDocs\n    // Returns the number of documents in the database.\n    var getTotalDocs = function() {\n        return totalDocs;\n    };\n    // #### Consolidate\n    // Consolidates the data structure of bm25 and computes the IDF. This must be\n    // built before using the `search` function. The `fp` defines the precision at\n    // which term frequency values are stored. The default value is **4**. In cause\n    // of an invalid input, it default to 4. The maximum permitted value is 9; any\n    // value larger than 9 is forced to 9.\n    var consolidate = function(fp) {\n        if (consolidated) throw Error(\"winkBM25S: consolidation can be carried out only once!\");\n        if (totalDocs < 3) throw Error(\"winkBM25S: document collection is too small for consolidation; add more docs!\");\n        var freqPrecision = parseInt(fp, 10);\n        freqPrecision = isNaN(freqPrecision) ? 4 : freqPrecision < 4 ? 4 : freqPrecision > 9 ? 9 : freqPrecision;\n        // Using the commonly used names but unfortunately they are very cryptic and\n        // *short*. **Must not use these variable names elsewhere**.\n        var b = config.bm25Params.b;\n        var k1 = config.bm25Params.k1;\n        var k = config.bm25Params.k;\n        var freq, id, n, normalizationFactor, t;\n        // Consolidate: compute idf; will multiply with freq to save multiplication\n        // time during search. This happens in the next loop-block.\n        for(var i = 0, imax = invertedIdx.length; i < imax; i += 1){\n            n = invertedIdx[i].length;\n            idf[i] = Math.log((totalDocs - n + 0.5) / (n + 0.5) + k);\n        // To be uncommented to probe values!\n        // console.log( '%s, %d, %d, %d, %d', t, totalDocs, n, k, idf[ t ] );\n        }\n        avgCorpusLength = totalCorpusLength / totalDocs;\n        // Consolidate: update document frequencies.\n        for(id in documents){\n            normalizationFactor = 1 - b + b * (documents[id].length / avgCorpusLength);\n            for(t in documents[id].freq){\n                freq = documents[id].freq[t];\n                // Update frequency but ensure the sign is carefully preserved as the\n                // magnitude of `k1` can jeopardize the sign!\n                documents[id].freq[t] = Math.sign(freq) * (Math.abs(freq * (k1 + 1) / (k1 * normalizationFactor + freq)) * idf[t]).toFixed(freqPrecision);\n            // To be uncommented to probe values!\n            // console.log( '%s, %s, %d', id, t, documents[ id ].freq[ t ] );\n            }\n        }\n        // Set `consolidated` as `true`.\n        consolidated = true;\n        return true;\n    }; // consolidate()\n    // #### Search\n    // Searches the `text` and return `limit` results. If `limit` is not sepcified\n    // then it will return a maximum of **10** results. The `result` is an array of\n    // containing `doc id` and `score` pairs array. If the `text` is not found, an\n    // empty array is returned. The `text` must be a string. The argurment `filter`\n    // is like `filter` of JS Array; it receive an object containing document's\n    // retained field name/value pairs along with the `params` (which is passed as\n    // the second argument). It is useful in limiting the search space or making the\n    // search more focussed.\n    var search = function(text, limit, filter, params) {\n        // Predict/Search only if learnings have been consolidated!\n        if (!consolidated) throw Error(\"winkBM25S: search is not possible unless learnings are consolidated!\");\n        if (typeof text !== \"string\") throw Error(\"winkBM25S: search text should be a string, instead found: \" + typeof text);\n        // Setup filter function\n        var f = typeof filter === \"function\" ? filter : function() {\n            return true;\n        };\n        // Tokenized `text`. Use search specific weights.\n        var tkns = prepareInput(text, \"search\")// Filter out tokens that do not exists in the vocabulary.\n        .filter(function(t) {\n            return token2Index[t] !== undefined;\n        })// Now map them to their respective indexes using `token2Index`.\n        .map(function(t) {\n            return token2Index[t];\n        });\n        // Search results go here as doc id/score pairs.\n        var results = Object.create(null);\n        // Helper variables.\n        var id, ids, t;\n        var i, imax, j, jmax;\n        // Iterate for every token in the preapred text.\n        for(j = 0, jmax = tkns.length; j < jmax; j += 1){\n            t = tkns[j];\n            // Use Inverted Idx to look up - accelerates search!<br/>\n            // Note, `ids` can never be `undefined` as **unknown** tokens have already\n            // been filtered.\n            ids = invertedIdx[t];\n            // Means the token exists in the vocabulary!\n            // Compute scores for every document.\n            for(i = 0, imax = ids.length; i < imax; i += 1){\n                id = ids[i];\n                if (f(documents[id].fieldValues, params)) results[id] = documents[id].freq[t] + (results[id] || 0);\n            // To be uncommented to probe values!\n            /* console.log( '%s, %d, %d, %d', t, documents[ id ].freq[ t ], idf[ t ], results[ id ] ); */ }\n        }\n        // Convert to a table in `[ id, score ]` format; sort and slice required number\n        // of resultant documents.\n        return $3de00a38380ef818$exports.object.table(results).sort($3de00a38380ef818$exports.array.descendingOnValue).slice(0, Math.max(limit || 10, 1));\n    }; // search()\n    // #### Reset\n    // Resets the BM25F completely by re-initializing all the learning\n    // related variables, except the preparatory tasks.\n    var reset = function() {\n        // Reset values of variables that are associated with learning; Therefore\n        // `pTasks` & `pTaskCount` are not re-initialized.\n        // Term Frequencies & length of each document.\n        documents = Object.create(null);\n        // Inverted Index for faster search\n        invertedIdx = [];\n        // IDF for each tokens\n        idf = [];\n        // Set true on first call to `addDoc/learn` to prevent changing config.\n        learned = false;\n        // The `addDoc()predict()` function checks for this being true; set\n        // in `consolidate()`.\n        consolidated = false;\n        // Total documents added.\n        totalDocs = 0;\n        // Total number of tokens across all documents added.\n        totalCorpusLength = 0;\n        // Their average.\n        avgCorpusLength = 0;\n        // BM25F Configuration; set up in `defineConfig()`.\n        config = null;\n        // The `token: index` mapping; `index` is used everywhere instead\n        // of the `token`\n        token2Index = Object.create(null);\n        // Index's initial value, incremented with every new word.\n        currTokenIndex = 0;\n        return true;\n    }; // reset()\n    // #### Export JSON\n    // Returns the learnings, along with `consolidated` flag, in JSON format.\n    var exportJSON = function() {\n        var docStats = Object.create(null);\n        docStats.totalCorpusLength = totalCorpusLength;\n        docStats.totalDocs = totalDocs;\n        docStats.consolidated = consolidated;\n        return JSON.stringify([\n            config,\n            docStats,\n            documents,\n            invertedIdx,\n            currTokenIndex,\n            token2Index,\n            // For future expansion but the import will have to have intelligence to\n            // set the default values and still ensure nothing breaks! Hopefully!!\n            {},\n            [],\n            []\n        ]);\n    }; // exportJSON()\n    // #### Import JSON\n    // Imports the `json` in to index after validating the format of input JSON.\n    // If validation fails then throws error; otherwise on success import it\n    // returns `true`. Note, importing leads to resetting the search engine.\n    var importJSON = function(json) {\n        if (!json) throw Error(\"winkBM25S: undefined or null JSON encountered, import failed!\");\n        // Validate json format\n        var isOK = [\n            $3de00a38380ef818$exports.object.isObject,\n            $3de00a38380ef818$exports.object.isObject,\n            $3de00a38380ef818$exports.object.isObject,\n            $3de00a38380ef818$exports.array.isArray,\n            Number.isInteger,\n            $3de00a38380ef818$exports.object.isObject,\n            $3de00a38380ef818$exports.object.isObject,\n            $3de00a38380ef818$exports.array.isArray,\n            $3de00a38380ef818$exports.array.isArray\n        ];\n        var parsedJSON = JSON.parse(json);\n        if (!$3de00a38380ef818$exports.array.isArray(parsedJSON) || parsedJSON.length !== isOK.length) throw Error(\"winkBM25S: invalid JSON encountered, can not import.\");\n        for(var i = 0; i < isOK.length; i += 1){\n            if (!isOK[i](parsedJSON[i])) throw Error(\"winkBM25S: invalid JSON encountered, can not import.\");\n        }\n        // All good, setup variable values.\n        // First reset everything.\n        reset();\n        // To prevent config change.\n        learned = true;\n        // Load variable values.\n        config = parsedJSON[0];\n        totalCorpusLength = parsedJSON[1].totalCorpusLength;\n        totalDocs = parsedJSON[1].totalDocs;\n        consolidated = parsedJSON[1].consolidated;\n        documents = parsedJSON[2];\n        invertedIdx = parsedJSON[3];\n        currTokenIndex = parsedJSON[4];\n        token2Index = parsedJSON[5];\n        // Return success.\n        return true;\n    }; // importJSON()\n    methods.definePrepTasks = definePrepTasks;\n    methods.defineConfig = defineConfig;\n    methods.addDoc = addDoc;\n    methods.getDocs = getDocs;\n    methods.getTokens = getTokens;\n    methods.getConfig = getConfig;\n    methods.getIDF = getIDF;\n    methods.getTotalCorpusLength = getTotalCorpusLength;\n    methods.getTotalDocs = getTotalDocs;\n    methods.consolidate = consolidate;\n    methods.search = search;\n    methods.exportJSON = exportJSON;\n    methods.importJSON = importJSON;\n    methods.reset = reset;\n    // Aliases to keep APIs uniform across.\n    methods.learn = addDoc;\n    methods.predict = search;\n    return methods;\n}; // bm25fIMS()\n$677849fcdd97ee5d$exports = $677849fcdd97ee5d$var$bm25fIMS;\n\n\nvar $cab6c4c6fef93ff0$exports = {};\n\"use strict\";\nvar $f79e0cabed2eba9f$exports = {};\n\"use strict\";\nvar $3f3b3750e38ae9e1$exports = {};\n\"use strict\";\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/ function $3f3b3750e38ae9e1$var$isArray(value) {\n    return Object.prototype.toString.call(value) === \"[object Array]\";\n} // end FUNCTION isArray()\n// EXPORTS //\n$3f3b3750e38ae9e1$exports = Array.isArray || $3f3b3750e38ae9e1$var$isArray;\n\n\nvar $ff4b8d177131cdf4$exports = {};\n/**\n*\n*\tVALIDATE: function\n*\n*\n*\tDESCRIPTION:\n*\t\t- Validates if a value is a function.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/ \"use strict\";\n/**\n* FUNCTION: isFunction( value )\n*\tValidates if a value is a function.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a function\n*/ function $ff4b8d177131cdf4$var$isFunction(value) {\n    return typeof value === \"function\";\n} // end FUNCTION isFunction()\n// EXPORTS //\n$ff4b8d177131cdf4$exports = $ff4b8d177131cdf4$var$isFunction;\n\n\n// DOT PRODUCT //\n/**\n* FUNCTION: dot( x, y[, accessor] )\n*\tComputes the dot product between two arrays.\n*\n* @param {Array} x - input array\n* @param {Array} y - input array\n* @param {Function} [accessor] - accessor function for accessing array values\n* @returns {Number|Null} dot product\n*/ function $f79e0cabed2eba9f$var$dot(x, y, clbk) {\n    if (!$3f3b3750e38ae9e1$exports(x)) throw new TypeError(\"dot()::invalid input argument. First argument must be an array. Value: `\" + x + \"`.\");\n    if (!$3f3b3750e38ae9e1$exports(y)) throw new TypeError(\"dot()::invalid input argument. Second argument must be an array. Value: `\" + y + \"`.\");\n    if (arguments.length > 2) {\n        if (!$ff4b8d177131cdf4$exports(clbk)) throw new TypeError(\"dot()::invalid input argument. Accessor must be a function. Value: `\" + clbk + \"`.\");\n    }\n    var len = x.length, sum = 0, i;\n    if (len !== y.length) throw new Error(\"dot()::invalid input argument. Arrays must be of equal length.\");\n    if (!len) return null;\n    if (clbk) for(i = 0; i < len; i++)sum += clbk(x[i], i, 0) * clbk(y[i], i, 1);\n    else for(i = 0; i < len; i++)sum += x[i] * y[i];\n    return sum;\n} // end FUNCTION dot()\n// EXPORTS //\n$f79e0cabed2eba9f$exports = $f79e0cabed2eba9f$var$dot;\n\n\nvar $d81d4f35676b436e$exports = {};\n\"use strict\";\n\n\n// L2NORM //\n/**\n* FUNCTION: l2norm( arr[, accessor] )\n*\tCalculates the L2 norm (Euclidean norm) of an array.\n*\n* @param {Array} arr - input array\n* @param {Function} [accessor] - accessor function for accessing array values\n* @returns {Number|Null} L2 norm or null\n*/ function $d81d4f35676b436e$var$l2norm(arr, clbk) {\n    if (!$3f3b3750e38ae9e1$exports(arr)) throw new TypeError(\"l2norm()::invalid input argument. Must provide an array.  Value: `\" + arr + \"`.\");\n    if (arguments.length > 1) {\n        if (!$ff4b8d177131cdf4$exports(clbk)) throw new TypeError(\"l2norm()::invalid input argument. Accessor must be a function. Value: `\" + clbk + \"`.\");\n    }\n    var len = arr.length, t = 0, s = 1, r, val, abs, i;\n    if (!len) return null;\n    if (clbk) for(i = 0; i < len; i++){\n        val = clbk(arr[i], i);\n        abs = val < 0 ? -val : val;\n        if (abs > 0) {\n            if (abs > t) {\n                r = t / val;\n                s = 1 + s * r * r;\n                t = abs;\n            } else {\n                r = val / t;\n                s = s + r * r;\n            }\n        }\n    }\n    else for(i = 0; i < len; i++){\n        val = arr[i];\n        abs = val < 0 ? -val : val;\n        if (abs > 0) {\n            if (abs > t) {\n                r = t / val;\n                s = 1 + s * r * r;\n                t = abs;\n            } else {\n                r = val / t;\n                s = s + r * r;\n            }\n        }\n    }\n    return t * Math.sqrt(s);\n} // end FUNCTION l2norm()\n// EXPORTS //\n$d81d4f35676b436e$exports = $d81d4f35676b436e$var$l2norm;\n\n\n\n\n// FUNCTIONS //\n/**\n* Partially applied function from the right.\n*\n* @private\n* @param {Function} fn - input function\n* @param {number} j - array index\n* @returns {Function} partially applied function\n*/ function $cab6c4c6fef93ff0$var$partial(fn, j) {\n    return function accessor(d, i) {\n        return fn(d, i, j);\n    };\n}\n// MAIN //\n/**\n* Computes the cosine similarity between two arrays.\n*\n* @param {number[]|Array} x - input array\n* @param {number[]|Array} y - input array\n* @param {Function} [accessor] - accessor function for accessing array values\n* @returns {number|null} cosine similarity or null\n*/ function $cab6c4c6fef93ff0$var$similarity(x, y, clbk) {\n    var a, b, c;\n    if (!$3f3b3750e38ae9e1$exports(x)) throw new TypeError(\"cosine-similarity()::invalid input argument. First argument must be an array. Value: `\" + x + \"`.\");\n    if (!$3f3b3750e38ae9e1$exports(y)) throw new TypeError(\"cosine-similarity()::invalid input argument. Second argument must be an array. Value: `\" + y + \"`.\");\n    if (arguments.length > 2) {\n        if (!$ff4b8d177131cdf4$exports(clbk)) throw new TypeError(\"cosine-similarity()::invalid input argument. Accessor must be a function. Value: `\" + clbk + \"`.\");\n    }\n    if (x.length !== y.length) throw new Error(\"cosine-similarity()::invalid input argument. Input arrays must have the same length.\");\n    if (!x.length) return null;\n    if (clbk) {\n        a = $f79e0cabed2eba9f$exports(x, y, clbk);\n        b = $d81d4f35676b436e$exports(x, $cab6c4c6fef93ff0$var$partial(clbk, 0));\n        c = $d81d4f35676b436e$exports(y, $cab6c4c6fef93ff0$var$partial(clbk, 1));\n    } else {\n        a = $f79e0cabed2eba9f$exports(x, y);\n        b = $d81d4f35676b436e$exports(x);\n        c = $d81d4f35676b436e$exports(y);\n    }\n    return a / (b * c);\n}\n// EXPORTS //\n$cab6c4c6fef93ff0$exports = $cab6c4c6fef93ff0$var$similarity;\n\n\n\n})();\n//# sourceMappingURL=search.js.map\n","import bm25 from 'wink-bm25-text-search';\nimport similarity from 'compute-cosine-similarity';\n","//     wink-bm25-text-search\n//\n//     Copyright (C) GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-bm25-text-search”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\nvar helpers = require( 'wink-helpers' );\n\n/* eslint guard-for-in: 0 */\n/* eslint complexity: [ \"error\", 25 ] */\n\n// It is a BM25F In-memory Search engine for text and exposes following\n// methods:\n// 1. `definePrepTasks` allows to define field-wise (optional) pipeline of\n// functions that will be used to prepare each input prior to *search/predict*\n// and *addDoc/learn*.\n// 2. `defineConfig` sets up the configuration for *field-wise weights*,\n// *BM25F parameters*, and **field names whoes original value** needs to be retained.\n// 3. `addDoc/learn` adds a document using its unique id. The document is supplied\n// as an Javascript object, where each property is the field of the document\n// and its value is the text.\n// 4. `consolidate` learnings prior to search/predict.\n// 5. `search/predict` searches for the input text and returns the resultant\n// document ids, sorted by their relevance along with the score. The number of\n// results returned can be controlled via a limit argument that defaults to **10**.\n// The last optional argument is a filter function that must return a `boolean`\n// value, which is used to filter documents.\n// 6. `exportJSON` exports the learnings in JSON format.\n// 7. `importJSON` imports the learnings from JSON that may have been saved on disk.\n// 8. `reset` all the learnings except the preparatory tasks.\nvar bm25fIMS = function () {\n  // Preparatory tasks that are executed on the `addDoc` & `search` input.\n  var pTasks = [];\n  // And its count.\n  var pTaskCount;\n  // Field level prep tasks.\n  var flds = Object.create( null );\n  // Returned!\n  var methods = Object.create( null );\n  // Term Frequencies & length of each document.\n  var documents = Object.create( null );\n  // Inverted Index for faster search\n  var invertedIdx = [];\n  // IDF for each tokens, tokens are referenced via their numerical index.\n  var idf = [];\n  // Set true on first call to `addDoc/learn` to prevent changing config.\n  var learned = false;\n  // The `addDoc()predict()` function checks for this being true; set\n  // in `consolidate()`.\n  var consolidated = false;\n  // Total documents added.\n  var totalDocs = 0;\n  // Total number of tokens across all documents added.\n  var totalCorpusLength = 0;\n  // Their average.\n  var avgCorpusLength = 0;\n  // BM25F Configuration; set up in `defineConfig()`.\n  var config = null;\n  // The `token: index` mapping; `index` is used everywhere instead\n  // of the `token`\n  var token2Index = Object.create( null );\n  // Index's initial value, incremented with every new word.\n  var currTokenIndex = 0;\n\n  // ### Private functions\n\n  // #### Perpare Input\n\n  // Prepares the `input` by executing the pipeline of tasks defined in the\n  // `field` specific `pTasks` set via `definePrepTasks()`.\n  // If `field` is not specified then default `pTasks` are used.\n  // If the `field` specific `pTasks` are not defined then it automatically\n  // switches to default `pTasks`.\n  var prepareInput = function ( input, field ) {\n    var processedInput = input;\n    var pt = ( flds[ field ] && flds[ field ].pTasks ) || pTasks;\n    var ptc = ( flds[ field ] && flds[ field ].pTaskCount ) || pTaskCount;\n    for ( var i = 0; i < ptc; i += 1 ) {\n      processedInput = pt[ i ]( processedInput );\n    }\n    return ( processedInput );\n  }; // prepareInput()\n\n  // #### Update Freq\n\n  // Updates the `freq` of each term in the `text` after pre-processing it via\n  // `prepareInput()`; while updating, it takes care of `field's` `weight`.\n  var updateFreq = function ( id, text, weight, freq, field ) {\n    // Tokenized `text`.\n    var tkns = prepareInput( text, field );\n    // Temp token holder.\n    var t;\n    for ( var i = 0, imax = tkns.length; i < imax; i += 1 ) {\n      t = tkns[ i ];\n      // Build `token: index` mapping.\n      if ( token2Index[ t ] === undefined ) {\n        token2Index[ t ] = currTokenIndex;\n        currTokenIndex += 1;\n      }\n      t = token2Index[ t ];\n      if ( freq[ t ] === undefined ) {\n        freq[ t ] = weight;\n        invertedIdx[ t ] = invertedIdx[ t ] || [];\n        invertedIdx[ t ].push( id );\n      } else {\n        freq[ t ] += weight;\n      }\n    }\n    // Length can not be negative!\n    return ( tkns.length * Math.abs( weight ) );\n  }; // updateFreq()\n\n  // ### Exposed Functions\n\n  // #### Define Prep Tasks\n\n  // Defines the `tasks` required to prepare the input for `addDoc` and `search()`\n  // The `tasks` should be an array of functions; using these function a simple\n  // pipeline is built to serially transform the input to the output.\n  // It validates the `tasks` before updating the `pTasks`.\n  // If validation fails it throws an appropriate error.\n  // Tasks can be defined separately for each field. However if the field is not\n  // specified (i.e. `null` or `undefined`), then the `tasks` become default.\n  // Note, `field = 'search'` is reserved for prep tasks for search string; However\n  // if the same is not specified, the default tasks are used for pre-processing.\n  var definePrepTasks = function ( tasks, field ) {\n    if ( config === null ) {\n      throw Error( 'winkBM25S: Config must be defined before defining prepTasks.' );\n    }\n    if ( !helpers.array.isArray( tasks ) ) {\n      throw Error( 'winkBM25S: Tasks should be an array, instead found: ' + JSON.stringify( tasks ) );\n    }\n    for ( var i = 0, imax = tasks.length; i < imax; i += 1 ) {\n      if ( typeof tasks[ i ] !== 'function' ) {\n        throw Error( 'winkBM25S: Tasks should contain function, instead found: ' + ( typeof tasks[ i ] ) );\n      }\n    }\n    var fldWeights = config.fldWeights;\n    if ( field === undefined || field === null ) {\n      pTasks = tasks;\n      pTaskCount = tasks.length;\n    } else {\n      if ( !fldWeights[ field ] || typeof field !== 'string' ) {\n        throw Error( 'winkBM25S: Field name is missing or it is not a string: ' + JSON.stringify( field ) + '/' + ( typeof field ) );\n      }\n      flds[ field ] = flds[ field ] || Object.create( null );\n      flds[ field ].pTasks = tasks;\n      flds[ field ].pTaskCount = tasks.length;\n    }\n    return tasks.length;\n  }; // definePrepTasks()\n\n  // #### Define Config\n\n  // Defines the configuration for BM25F using `fldWeights` and `bm25Params`\n  // properties of `cfg` object.</br>\n  // The `fldWeights` defines the weight for each field of the document. This gives\n  // a semantic nudge to search and are used as a mutiplier to the count\n  // (frequency) of each token contained in that field of the document. It should\n  // be a JS object containing `field-name/value` pairs. If a field's weight is\n  // not defined, that field is **ignored**. The field weights must be defined before\n  // attempting to add a document via `addDoc()`; they can only be defined once.\n  // If any document's field is not defined here then that field is **ignored**.\n  // </br>\n  // The `k`, `b` and `k1` properties of `bm25Params` object define the smoothing\n  // factor for IDF, degree of normalization for TF, and saturation control factor\n  // respectively for the BM25F. Their default values are **1**, **0.75**, and\n  // **1.2**.<br/>\n  // The `ovFieldNames` is an array of field names whose original value needs to\n  // be retained.\n  var defineConfig = function ( cfg ) {\n    if ( learned ) {\n      throw Error( 'winkBM25S: config must be defined before learning/addition starts!' );\n    }\n    if ( !helpers.object.isObject( cfg ) ) {\n      throw Error( 'winkBM25S: config must be a config object, instead found: ' + JSON.stringify( cfg ) );\n    }\n    // If `fldWeights` are absent throw error.\n    if ( !helpers.object.isObject( cfg.fldWeights ) ) {\n      throw Error( 'winkBM25S: fldWeights must be an object, instead found: ' + JSON.stringify( cfg.fldWeights ) );\n    }\n    // There should be at least one defined field!\n    if ( ( helpers.object.keys( cfg.fldWeights ) ).length === 0 ) {\n      throw Error( 'winkBM25S: Field config has no field defined.' );\n    }\n    // Setup configuration now.\n    config = Object.create( null );\n      // Field config for BM25**F**\n    config.fldWeights = Object.create( null );\n    config.bm25Params = Object.create( null );\n    // **Controls TF part:**<br/>\n    // `k1` controls saturation of token's frequency; higher value delays saturation\n    // with increase in frequency.\n    config.bm25Params.k1 = 1.2;\n    // `b` controls the degree of normalization; **0** means no normalization and **1**\n    // indicates complete normalization!\n    config.bm25Params.b = 0.75;\n    // **Controls IDF part:**<br/>\n    // `k` controls impact of IDF; should be >= 0; a higher value means lower\n    // the impact of IDF.\n    config.bm25Params.k = 1;\n    // Setup field weights.\n    for ( var field in cfg.fldWeights ) {\n      // The `null` check is required as `isNaN( null )` returns `false`!!\n      // This first ensures non-`null/undefined/0` values before testing for NaN.\n      if ( !cfg.fldWeights[ field ] || isNaN( cfg.fldWeights[ field ] ) ) {\n        throw Error( 'winkBM25S: Field weight should be number >0, instead found: ' + JSON.stringify( cfg.fldWeights[ field ] ) );\n      }\n      // Update config parameters from `cfg`.\n      config.fldWeights[ field ] = ( +cfg.fldWeights[ field ] );\n    }\n    // Setup BM25F params.\n    // Create `bm25Params` if absent in `cfg`.\n    if ( !helpers.object.isObject( cfg.bm25Params ) ) cfg.bm25Params = Object.create( null );\n    // Update config parameters from `cfg`.\n    config.bm25Params.b = (\n                            ( cfg.bm25Params.b === null ) ||\n                            ( cfg.bm25Params.b === undefined ) ||\n                            ( isNaN( cfg.bm25Params.b ) ) ||\n                            ( +cfg.bm25Params.b < 0 || +cfg.bm25Params.b > 1 )\n                          ) ? 0.75 : +cfg.bm25Params.b;\n\n    // Update config parameters from `cfg`.\n    config.bm25Params.k1 = (\n                            ( cfg.bm25Params.k1 === null ) ||\n                            ( cfg.bm25Params.k1 === undefined ) ||\n                            ( isNaN( cfg.bm25Params.k1 ) ) ||\n                            ( +cfg.bm25Params.k1 < 0 )\n                           ) ? 1.2 : +cfg.bm25Params.k1;\n\n    // Update config parameters from `cfg`.\n    config.bm25Params.k = (\n                            ( cfg.bm25Params.k === null ) ||\n                            ( cfg.bm25Params.k === undefined ) ||\n                            ( isNaN( cfg.bm25Params.k ) ) ||\n                            ( +cfg.bm25Params.k < 0 )\n                          ) ? 1 : +cfg.bm25Params.k;\n\n    // Handle configuration for fields whose orginal values has to be retained\n    // in the document.<br/>\n    // Initialize the `ovFldNames` in the final `config` as an empty array\n    config.ovFldNames = [];\n    if ( !cfg.ovFldNames ) cfg.ovFldNames = [];\n    if ( !helpers.array.isArray(cfg.ovFldNames) ) {\n      throw Error( 'winkBM25S: OV Field names should be an array, instead found: ' + JSON.stringify( typeof cfg.ovFldNames ) );\n    }\n\n    cfg.ovFldNames.forEach( function ( f ) {\n      if ( ( typeof f !== 'string' ) || ( f.length === 0 ) ) {\n        throw Error( 'winkBM25S: OV Field name should be a non-empty string, instead found: ' + JSON.stringify( f ) );\n      }\n      config.ovFldNames.push( f );\n    } );\n    return true;\n  }; // defineConfig()\n\n\n  // #### Add Doc\n\n  // Adds a document to the model using `updateFreq()` function.\n  var addDoc = function ( doc, id ) {\n    if ( config === null ) {\n      throw Error( 'winkBM25S: Config must be defined before adding a document.' );\n    }\n    var fldWeights = config.fldWeights;\n    // No point in adding/learning further in absence of consolidated.\n    if ( consolidated ) {\n      throw Error( 'winkBM25S: post consolidation adding/learning is not possible!' );\n    }\n    // Set learning/addition started.\n    learned = true;\n    var length;\n    if ( documents[ id ] !== undefined ) {\n      throw Error( 'winkBM25S: Duplicate document encountered: ' + JSON.stringify( id ) );\n    }\n    documents[ id ] = Object.create( null );\n    documents[ id ].freq = Object.create( null );\n    documents[ id ].fieldValues = Object.create( null );\n    documents[ id ].length = 0;\n    // Compute `freq` & `length` of the specified fields.\n    for ( var field in fldWeights ) {\n      if ( doc[ field ] === undefined ) {\n        throw Error( 'winkBM25S: Missing field in the document: ' + JSON.stringify( field ) );\n      }\n      length = updateFreq( id, doc[ field ], fldWeights[ field ], documents[ id ].freq, field );\n      documents[ id ].length += length;\n      totalCorpusLength += length;\n    }\n    // Retain Original Field Values, if configured.\n    config.ovFldNames.forEach( function ( f ) {\n      if ( doc[ f ] === undefined ) {\n        throw Error( 'winkBM25S: Missing field in the document: ' + JSON.stringify( f ) );\n      }\n      documents[ id ].fieldValues[ f ] = doc[ f ];\n    } );\n    // Increment total documents indexed so far.\n    totalDocs += 1;\n    return ( totalDocs );\n  }; // addDoc()\n\n  // #### Get Docs\n\n  // Returns the document database.\n  var getDocs = function () {\n    return documents;\n  };\n\n  // #### Get Tokens\n\n  // Returns the token to token ID database.\n  var getTokens = function () {\n    return token2Index;\n  };\n\n  // #### Get IDF\n\n  // Returns token ID to IDF database.\n  var getIDF = function () {\n    return idf;\n  };\n\n  // #### Get Config\n\n  // Returns the config.\n  var getConfig = function () {\n    return config;\n  };\n\n  // #### Get TotalCorpusLength\n\n  // Returns the number of tokens in the database.\n  var getTotalCorpusLength = function () {\n    return totalCorpusLength;\n  };\n\n  // #### Get TotalDocs\n\n  // Returns the number of documents in the database.\n  var getTotalDocs = function () {\n    return totalDocs;\n  };\n\n  // #### Consolidate\n\n  // Consolidates the data structure of bm25 and computes the IDF. This must be\n  // built before using the `search` function. The `fp` defines the precision at\n  // which term frequency values are stored. The default value is **4**. In cause\n  // of an invalid input, it default to 4. The maximum permitted value is 9; any\n  // value larger than 9 is forced to 9.\n  var consolidate = function ( fp ) {\n    if ( consolidated ) {\n      throw Error( 'winkBM25S: consolidation can be carried out only once!' );\n    }\n    if ( totalDocs < 3 ) {\n      throw Error( 'winkBM25S: document collection is too small for consolidation; add more docs!' );\n    }\n    var freqPrecision = parseInt( fp, 10 );\n    freqPrecision = ( isNaN( freqPrecision ) ) ? 4 :\n                      ( freqPrecision < 4 ) ? 4 :\n                        ( freqPrecision > 9 ) ? 9 : freqPrecision;\n    // Using the commonly used names but unfortunately they are very cryptic and\n    // *short*. **Must not use these variable names elsewhere**.\n    var b = config.bm25Params.b;\n    var k1 = config.bm25Params.k1;\n    var k = config.bm25Params.k;\n    var freq, id, n, normalizationFactor, t;\n    // Consolidate: compute idf; will multiply with freq to save multiplication\n    // time during search. This happens in the next loop-block.\n    for ( var i = 0, imax = invertedIdx.length; i < imax; i += 1 ) {\n      n = invertedIdx[ i ].length;\n      idf[ i ] = Math.log( ( ( totalDocs - n + 0.5 ) / ( n + 0.5 ) ) + k );\n      // To be uncommented to probe values!\n      // console.log( '%s, %d, %d, %d, %d', t, totalDocs, n, k, idf[ t ] );\n    }\n    avgCorpusLength = totalCorpusLength / totalDocs;\n    // Consolidate: update document frequencies.\n    for ( id in documents ) {\n      normalizationFactor = ( 1 - b ) + ( b * ( documents[ id ].length / avgCorpusLength ) );\n      for ( t in documents[ id ].freq ) {\n        freq = documents[ id ].freq[ t ];\n        // Update frequency but ensure the sign is carefully preserved as the\n        // magnitude of `k1` can jeopardize the sign!\n        documents[ id ].freq[ t ] = Math.sign( freq ) *\n          ( Math.abs( ( freq * ( k1 + 1 ) ) / ( ( k1 * normalizationFactor ) + freq ) ) *\n          idf[ t ] ).toFixed( freqPrecision );\n        // To be uncommented to probe values!\n        // console.log( '%s, %s, %d', id, t, documents[ id ].freq[ t ] );\n      }\n    }\n    // Set `consolidated` as `true`.\n    consolidated = true;\n    return true;\n  }; // consolidate()\n\n  // #### Search\n\n  // Searches the `text` and return `limit` results. If `limit` is not sepcified\n  // then it will return a maximum of **10** results. The `result` is an array of\n  // containing `doc id` and `score` pairs array. If the `text` is not found, an\n  // empty array is returned. The `text` must be a string. The argurment `filter`\n  // is like `filter` of JS Array; it receive an object containing document's\n  // retained field name/value pairs along with the `params` (which is passed as\n  // the second argument). It is useful in limiting the search space or making the\n  // search more focussed.\n  var search = function ( text, limit, filter, params ) {\n    // Predict/Search only if learnings have been consolidated!\n    if ( !consolidated ) {\n      throw Error( 'winkBM25S: search is not possible unless learnings are consolidated!' );\n    }\n    if ( typeof text !== 'string' ) {\n      throw Error( 'winkBM25S: search text should be a string, instead found: ' + ( typeof text ) );\n    }\n    // Setup filter function\n    var f = ( typeof filter === 'function' ) ?\n              filter :\n              function () {\n                return true;\n              };\n    // Tokenized `text`. Use search specific weights.\n    var tkns = prepareInput( text, 'search' )\n                // Filter out tokens that do not exists in the vocabulary.\n                .filter( function ( t ) {\n                   return ( token2Index[ t ] !== undefined );\n                 } )\n                // Now map them to their respective indexes using `token2Index`.\n                .map( function ( t ) {\n                   return token2Index[ t ];\n                 } );\n    // Search results go here as doc id/score pairs.\n    var results = Object.create( null );\n    // Helper variables.\n    var id, ids, t;\n    var i, imax, j, jmax;\n    // Iterate for every token in the preapred text.\n    for ( j = 0, jmax = tkns.length; j < jmax; j += 1 ) {\n      t = tkns[ j ];\n      // Use Inverted Idx to look up - accelerates search!<br/>\n      // Note, `ids` can never be `undefined` as **unknown** tokens have already\n      // been filtered.\n      ids = invertedIdx[ t ];\n      // Means the token exists in the vocabulary!\n      // Compute scores for every document.\n      for ( i = 0, imax = ids.length; i < imax; i += 1 ) {\n        id = ids[ i ];\n        if ( f( documents[ id ].fieldValues, params ) ) {\n          results[ id ] = documents[ id ].freq[ t ] + ( results[ id ] || 0 );\n        }\n        // To be uncommented to probe values!\n        /* console.log( '%s, %d, %d, %d', t, documents[ id ].freq[ t ], idf[ t ], results[ id ] ); */\n      }\n    }\n    // Convert to a table in `[ id, score ]` format; sort and slice required number\n    // of resultant documents.\n    return ( ( helpers.object.table( results ) )\n                .sort( helpers.array.descendingOnValue )\n                .slice( 0, Math.max( ( limit || 10 ), 1 ) )\n           );\n  }; // search()\n\n  // #### Reset\n\n  // Resets the BM25F completely by re-initializing all the learning\n  // related variables, except the preparatory tasks.\n  var reset = function () {\n    // Reset values of variables that are associated with learning; Therefore\n    // `pTasks` & `pTaskCount` are not re-initialized.\n    // Term Frequencies & length of each document.\n    documents = Object.create( null );\n    // Inverted Index for faster search\n    invertedIdx = [];\n    // IDF for each tokens\n    idf = [];\n    // Set true on first call to `addDoc/learn` to prevent changing config.\n    learned = false;\n    // The `addDoc()predict()` function checks for this being true; set\n    // in `consolidate()`.\n    consolidated = false;\n    // Total documents added.\n    totalDocs = 0;\n    // Total number of tokens across all documents added.\n    totalCorpusLength = 0;\n    // Their average.\n    avgCorpusLength = 0;\n    // BM25F Configuration; set up in `defineConfig()`.\n    config = null;\n    // The `token: index` mapping; `index` is used everywhere instead\n    // of the `token`\n    token2Index = Object.create( null );\n    // Index's initial value, incremented with every new word.\n    currTokenIndex = 0;\n    return true;\n  }; // reset()\n\n  // #### Export JSON\n\n  // Returns the learnings, along with `consolidated` flag, in JSON format.\n  var exportJSON = function ( ) {\n    var docStats = Object.create( null );\n    docStats.totalCorpusLength = totalCorpusLength;\n    docStats.totalDocs = totalDocs;\n    docStats.consolidated = consolidated;\n    return ( JSON.stringify( [\n      config,\n      docStats,\n      documents,\n      invertedIdx,\n      currTokenIndex,\n      token2Index,\n      // For future expansion but the import will have to have intelligence to\n      // set the default values and still ensure nothing breaks! Hopefully!!\n      {},\n      [],\n      []\n    ] ) );\n  }; // exportJSON()\n\n  // #### Import JSON\n\n  // Imports the `json` in to index after validating the format of input JSON.\n  // If validation fails then throws error; otherwise on success import it\n  // returns `true`. Note, importing leads to resetting the search engine.\n  var importJSON = function ( json ) {\n    if ( !json ) {\n      throw Error( 'winkBM25S: undefined or null JSON encountered, import failed!' );\n    }\n    // Validate json format\n    var isOK = [\n      helpers.object.isObject,\n      helpers.object.isObject,\n      helpers.object.isObject,\n      helpers.array.isArray,\n      Number.isInteger,\n      helpers.object.isObject,\n      helpers.object.isObject,\n      helpers.array.isArray,\n      helpers.array.isArray\n    ];\n    var parsedJSON = JSON.parse( json );\n    if ( !helpers.array.isArray( parsedJSON ) || parsedJSON.length !== isOK.length ) {\n      throw Error( 'winkBM25S: invalid JSON encountered, can not import.' );\n    }\n    for ( var i = 0; i < isOK.length; i += 1 ) {\n      if ( !isOK[ i ]( parsedJSON[ i ] ) ) {\n        throw Error( 'winkBM25S: invalid JSON encountered, can not import.' );\n      }\n    }\n    // All good, setup variable values.\n    // First reset everything.\n    reset();\n    // To prevent config change.\n    learned = true;\n    // Load variable values.\n    config = parsedJSON[ 0 ];\n    totalCorpusLength = parsedJSON[ 1 ].totalCorpusLength;\n    totalDocs = parsedJSON[ 1 ].totalDocs;\n    consolidated = parsedJSON[ 1 ].consolidated;\n    documents = parsedJSON[ 2 ];\n    invertedIdx = parsedJSON[ 3 ];\n    currTokenIndex = parsedJSON[ 4 ];\n    token2Index = parsedJSON[ 5 ];\n    // Return success.\n    return true;\n  }; // importJSON()\n\n  methods.definePrepTasks = definePrepTasks;\n  methods.defineConfig = defineConfig;\n  methods.addDoc = addDoc;\n  methods.getDocs = getDocs;\n  methods.getTokens = getTokens;\n  methods.getConfig = getConfig;\n  methods.getIDF = getIDF;\n  methods.getTotalCorpusLength = getTotalCorpusLength;\n  methods.getTotalDocs = getTotalDocs;\n  methods.consolidate = consolidate;\n  methods.search = search;\n  methods.exportJSON = exportJSON;\n  methods.importJSON = importJSON;\n  methods.reset = reset;\n  // Aliases to keep APIs uniform across.\n  methods.learn = addDoc;\n  methods.predict = search;\n\n  return ( methods );\n}; // bm25fIMS()\n\nmodule.exports = bm25fIMS;\n","//     wink-helpers\n//     Functions for cross validation, shuffle, cartesian product and more\n//\n//     Copyright (C) 2017-18  GRAYPE Systems Private Limited\n//\n//     This file is part of “wink-helpers”.\n//\n//     Permission is hereby granted, free of charge, to any person obtaining a\n//     copy of this software and associated documentation files (the \"Software\"),\n//     to deal in the Software without restriction, including without limitation\n//     the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//     and/or sell copies of the Software, and to permit persons to whom the\n//     Software is furnished to do so, subject to the following conditions:\n//\n//     The above copyright notice and this permission notice shall be included\n//     in all copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//     DEALINGS IN THE SOFTWARE.\n\n//\nvar helpers = Object.create( null );\n\n// ### Private Functions\n\n// #### Product Reducer (Callback)\n\n// Callback function used by `reduce` inside the `product()` function.\n// Follows the standard guidelines of `reduce()` callback function.\nvar productReducer = function ( prev, curr ) {\n  var c,\n      cmax = curr.length;\n  var p,\n      pmax = prev.length;\n  var result = [];\n\n  for ( p = 0; p < pmax; p += 1 ) {\n    for ( c = 0; c < cmax; c += 1 ) {\n      result.push( prev[ p ].concat( curr[ c ] ) );\n    }\n  }\n  return ( result );\n}; // productReducer()\n\n// ### Public Function\n\n// ### Array Helpers\n\nhelpers.array = Object.create( null);\n\n// #### is Array\n\n// Tests if argument `v` is a JS array; returns `true` if it is, otherwise returns `false`.\nhelpers.array.isArray = function ( v ) {\n  return ( ( v !== undefined ) && ( v !== null ) && ( Object.prototype.toString.call( v ) === '[object Array]' ) );\n}; // isArray()\n\n\n// #### sorting helpers\n\n// Set of helpers to sort either numbers or strings. For key/value pairs,\n// the format for each element must be `[ key, value ]`.\n// Sort helper to sort an array in ascending order.\nhelpers.array.ascending = function ( a, b ) {\n  return ( a > b ) ? 1 :\n            ( a === b ) ? 0 : -1;\n}; // ascending()\n\n// Sort helper to sort an array in descending order.\nhelpers.array.descending = function ( a, b ) {\n  return ( b > a ) ? 1 :\n            ( b === a ) ? 0 : -1;\n}; // descending()\n\n// Sort helper to sort an array of `[ key, value ]` in ascending order by **key**.\nhelpers.array.ascendingOnKey = function ( a, b ) {\n  return ( a[ 0 ] > b[ 0 ] ) ? 1 :\n            ( a[ 0 ] === b[ 0 ] ) ? 0 : -1;\n}; // ascendingOnKey()\n\n// Sort helper to sort an array of `[ key, value ]` in descending order by **key**.\nhelpers.array.descendingOnKey = function ( a, b ) {\n  return ( b[ 0 ] > a[ 0 ] ) ? 1 :\n            ( b[ 0 ] === a[ 0 ] ) ? 0 : -1;\n}; // descendingOnKey()\n\n// Sort helper to sort an array of `[ key, value ]` in ascending order by **value**.\nhelpers.array.ascendingOnValue = function ( a, b ) {\n  return ( a[ 1 ] > b[ 1 ] ) ? 1 :\n            ( a[ 1 ] === b[ 1 ] ) ? 0 : -1;\n}; // ascendingOnValue()\n\n// Sort helper to sort an array of `[ key, value ]` in descending order by **value**.\nhelpers.array.descendingOnValue = function ( a, b ) {\n  return ( b[ 1 ] > a[ 1 ] ) ? 1 :\n            ( b[ 1 ] === a[ 1 ] ) ? 0 : -1;\n}; // descendingOnValue()\n\n// The following two functions generate a suitable function for sorting on a single\n// key or on a composite keys (max 2 only). Just a remider, the generated function\n// does not sort on two keys; instead it will sort on a key composed of the two\n// accessors.\n// Sorts in ascending order on `accessor1` & `accessor2` (optional).\nhelpers.array.ascendingOn = function ( accessor1, accessor2 ) {\n  if ( accessor2 ) {\n    return ( function ( a, b ) {\n      return ( a[ accessor1 ][ accessor2 ] > b[ accessor1 ][ accessor2 ] ) ? 1 :\n              ( a[ accessor1 ][ accessor2 ] === b[ accessor1 ][ accessor2 ] ) ? 0 : -1;\n    } );\n  }\n  return ( function ( a, b ) {\n    return ( a[ accessor1 ] > b[ accessor1 ] ) ? 1 :\n            ( a[ accessor1 ] === b[ accessor1 ] ) ? 0 : -1;\n  } );\n}; // ascendingOn()\n\n// Sorts in descending order on `accessor1` & `accessor2` (optional).\nhelpers.array.descendingOn = function ( accessor1, accessor2 ) {\n  if ( accessor2 ) {\n    return ( function ( a, b ) {\n      return ( b[ accessor1 ][ accessor2 ] > a[ accessor1 ][ accessor2 ] ) ? 1 :\n              ( b[ accessor1 ][ accessor2 ] === a[ accessor1 ][ accessor2 ] ) ? 0 : -1;\n    } );\n  }\n  return ( function ( a, b ) {\n    return ( b[ accessor1 ] > a[ accessor1 ] ) ? 1 :\n            ( b[ accessor1 ] === a[ accessor1 ] ) ? 0 : -1;\n  } );\n}; // descendingOn()\n\n// #### pluck\n\n// Plucks specified element from each element of an **array of array**, and\n// returns the resultant array. The element is specified by `i` (default `0`) and\n// number of elements to pluck are defined by `limit` (default `a.length`).\nhelpers.array.pluck = function ( a, key, limit ) {\n  var k, plucked;\n  k = a.length;\n  var i = key || 0;\n  var lim = limit || k;\n  if ( lim > k ) lim = k;\n  plucked = new Array( lim );\n  for ( k = 0; k < lim; k += 1 ) plucked[ k ] = a[ k ][ i ];\n  return plucked;\n}; // pluck()\n\n// #### product\n\n// Finds the Cartesian Product of arrays present inside the array `a`. Therefore\n// the array `a` must be an array of 1-dimensional arrays. For example,\n// `product( [ [ 9, 8 ], [ 1, 2 ] ] )`\n// will produce `[ [ 9, 1 ], [ 9, 2 ], [ 8, 1 ], [ 8, 2 ] ]`.\nhelpers.array.product = function ( a ) {\n  return (\n    a.reduce( productReducer, [ [] ] )\n  );\n};\n\n// #### shuffle\n\n// Randomly shuffles the elements of an array and returns the same.\n// Reference: Chapter on Random Numbers/Shuffling in Seminumerical algorithms.\n// The Art of Computer Programming Volume II by Donald E Kunth\nhelpers.array.shuffle = function ( array ) {\n  var a = array;\n  var balance = a.length;\n  var candidate;\n  var temp;\n\n  while ( balance ) {\n    candidate = Math.floor( Math.random() * balance );\n    balance -= 1;\n\n    temp = a[ balance ];\n    a[ balance ] = a[ candidate ];\n    a[ candidate ] = temp;\n  }\n\n  return ( a );\n};\n\n\n// ### Object Helpers\n\nvar objectKeys = Object.keys;\nvar objectCreate = Object.create;\n\nhelpers.object = Object.create( null );\n\n// #### is Object\n\n// Tests if argument `v` is a JS object; returns `true` if it is, otherwise returns `false`.\nhelpers.object.isObject = function ( v ) {\n  return ( v && ( Object.prototype.toString.call( v ) === '[object Object]' ) ) ? true : false; // eslint-disable-line no-unneeded-ternary\n\n}; // isObject()\n\n// #### keys\n\n// Returns keys of the `obj` in an array.\nhelpers.object.keys = function ( obj ) {\n  return ( objectKeys( obj ) );\n}; // keys()\n\n// #### size\n\n// Returns the number of keys of the `obj`.\nhelpers.object.size = function ( obj ) {\n  return ( ( objectKeys( obj ) ).length );\n}; // size()\n\n// #### values\n\n// Returns all values from each key/value pair of the `obj` in an array.\nhelpers.object.values = function ( obj ) {\n  var keys = helpers.object.keys( obj );\n  var length = keys.length;\n  var values = new Array( length );\n  for ( var i = 0; i < length; i += 1 ) {\n    values[ i ] = obj[ keys[ i ] ];\n  }\n  return values;\n}; // values()\n\n// #### value Freq\n\n// Returns the frequency of each unique value present in the `obj`, where the\n// **key** is the *value* and **value** is the *frequency*.\nhelpers.object.valueFreq = function ( obj ) {\n  var keys = helpers.object.keys( obj );\n  var length = keys.length;\n  var val;\n  var vf = objectCreate( null );\n  for ( var i = 0; i < length; i += 1 ) {\n    val = obj[ keys[ i ] ];\n    vf[ val ] = 1 + ( vf[ val ] || 0 );\n  }\n  return vf;\n}; // valueFreq()\n\n// #### table\n\n// Converts the `obj` in to an array of `[ key, value ]` pairs in form of a table.\n// Second argument - `f` is optional and it is a function, which is called with\n// each `value`.\nhelpers.object.table = function ( obj, f ) {\n  var keys = helpers.object.keys( obj );\n  var length = keys.length;\n  var pairs = new Array( length );\n  var ak, av;\n  for ( var i = 0; i < length; i += 1 ) {\n    ak = keys[ i ];\n    av = obj[ ak ];\n    if ( typeof f === 'function' ) f( av );\n    pairs[ i ] = [ ak, av ];\n  }\n  return pairs;\n}; // table()\n\n// ### Validation Helpers\n\nhelpers.validate = Object.create( null );\n\n// Create aliases for isObject and isArray.\nhelpers.validate.isObject = helpers.object.isObject;\nhelpers.validate.isArray = helpers.array.isArray;\n\n// #### isFiniteInteger\n\n// Validates if `n` is a finite integer.\nhelpers.validate.isFiniteInteger = function ( n ) {\n  return (\n    ( typeof n === 'number' ) &&\n    !isNaN( n ) &&\n    isFinite( n ) &&\n    ( n === Math.round( n ) )\n  );\n}; // isFiniteInteger()\n\n// #### isFiniteNumber\n\n// Validates if `n` is a valid number.\nhelpers.validate.isFiniteNumber = function ( n ) {\n  return (\n    ( typeof n === 'number' ) &&\n    !isNaN( n ) &&\n    isFinite( n )\n  );\n}; // isFiniteNumber()\n\n// ### cross validation\n/**\n *\n * Creates an instance of cross validator useful for machine learning tasks.\n *\n * @param {string[]} classLabels - array containing all the class labels.\n * @return {methods} object conatining set of API methods for tasks like evalutaion,\n * reset and metrics generation.\n*/\nhelpers.validate.cross = function ( classLabels ) {\n  // wink's const for unknown predictions!\n  const unknown = 'unknown';\n  // To ensure that metrics is not computed prior to evaluation.\n  var evaluated = false;\n  // The confusion matrix.\n  var cm;\n  var precision;\n  var recall;\n  var fmeasure;\n\n  // The class labels is assigned to this variable.\n  var labels;\n  // The length of `labels` array.\n  var labelCount;\n  var labelsObj = Object.create( null );\n\n  // Returned!\n  var methods = Object.create( null );\n\n\n  /**\n   *\n   * Resets the current instance for another round of evaluation; the class\n   * labels defined at instance creation time are not touched.\n   *\n   * @return {undefined} nothing!\n  */\n  var reset = function ( ) {\n    evaluated = false;\n    cm = Object.create( null );\n    precision = Object.create( null );\n    recall = Object.create( null );\n    fmeasure = Object.create( null );\n\n    // Initialize confusion matrix and metrics.\n    for ( let i = 0; i < labelCount; i += 1 ) {\n      const row = labels[ i ];\n      labelsObj[ row ] = true;\n      cm[ row ] = Object.create( null );\n      precision[ row ] = 0;\n      recall[ row ] = 0;\n      fmeasure[ row ] = 0;\n      for ( let j = 0; j < labelCount; j += 1 ) {\n        const col = labels[ j ];\n        cm[ row ][ col ] = 0;\n      }\n    }\n  }; // reset()\n\n  /**\n   *\n   * Creates an instance of cross validator useful for machine learning tasks.\n   *\n   * @param {string} truth - the actual class label.\n   * @param {string} guess - the predicted class label.\n   * @return {boolean} returns true if the evaluation is successful. The evaluation\n   * may fail if `truth` or `guess` is not in the array `classLabels` provided at\n   * instance creation time; or if guess is equal to `unknown`.\n  */\n  var evaluate = function ( truth, guess ) {\n    // If prediction failed then return false!\n    if ( guess === unknown || !labelsObj[ truth ] || !labelsObj[ guess ] ) return false;\n    // Update confusion matrix.\n    if ( guess === truth ) {\n      cm[ truth ][ guess ] += 1;\n    } else {\n      cm[ guess ][ truth ] += 1;\n    }\n    evaluated = true;\n    return true;\n  }; // evaluate()\n\n  /**\n   *\n   * It computes a detailed metrics consisting of macro-averaged precision,\n   * recall and f-measure along with their label-wise values and the confusion\n   * matrix.\n   *\n   * @return {object} object containing macro-averaged `avgPrecision`, `avgRecall`,\n   * `avgFMeasure` values along with other details such as label-wise values\n   * and the confusion matrix. A value of `null` is returned if no evaluate()\n   * has been called before.\n  */\n  var metrics = function ( ) {\n    if ( !evaluated ) return null;\n    // Numerators for every label; they are same for precision & recall both.\n    var n = Object.create( null );\n    // Only denominators differs for precision & recall\n    var pd = Object.create( null );\n    var rd = Object.create( null );\n    // `row` and `col` of confusion matrix.\n    var col, row;\n    var i, j;\n    // Macro average values for metrics.\n    var avgPrecision = 0;\n    var avgRecall = 0;\n    var avgFMeasure = 0;\n\n    // Compute label-wise numerators & denominators!\n    for ( i = 0; i < labelCount; i += 1 ) {\n      row = labels[ i ];\n      for ( j = 0; j < labelCount; j += 1 ) {\n        col = labels[ j ];\n        if ( row === col ) {\n          n[ row ] = cm[ row ][ col ];\n        }\n        pd[ row ] = cm[ row ][ col ] + ( pd[ row ] || 0 );\n        rd[ row ] = cm[ col ][ row ] + ( rd[ row ] || 0 );\n      }\n    }\n    // Ready to compute metrics.\n    for ( i = 0; i < labelCount; i += 1 ) {\n      row = labels[ i ];\n      precision[ row ] = +( n[ row ] / pd[ row ] ).toFixed( 4 );\n      // NaN can occur if a label has not been encountered.\n      if ( isNaN( precision[ row ] ) ) precision[ row ] = 0;\n\n      recall[ row ] = +( n[ row ] / rd[ row ] ).toFixed( 4 );\n      if ( isNaN( recall[ row ] ) ) recall[ row ] = 0;\n\n      fmeasure[ row ] = +( 2 * precision[ row ] * recall[ row ] / ( precision[ row ] + recall[ row ] ) ).toFixed( 4 );\n      if ( isNaN( fmeasure[ row ] ) ) fmeasure[ row ] = 0;\n    }\n    // Compute thier averages, note they will be macro avegages.\n    for ( i = 0; i < labelCount; i += 1 ) {\n      avgPrecision += ( precision[ labels[ i ] ] / labelCount );\n      avgRecall += ( recall[ labels[ i ] ] / labelCount );\n      avgFMeasure += ( fmeasure[ labels[ i ] ] / labelCount );\n    }\n    // Return metrics.\n    return (\n      {\n        // Macro-averaged metrics.\n        avgPrecision: +avgPrecision.toFixed( 4 ),\n        avgRecall: +avgRecall.toFixed( 4 ),\n        avgFMeasure: +avgFMeasure.toFixed( 4 ),\n        details: {\n          // Confusion Matrix.\n          confusionMatrix: cm,\n          // Label wise metrics details, from those averages were computed.\n          precision: precision,\n          recall: recall,\n          fmeasure: fmeasure\n        }\n      }\n    );\n  }; // metrics()\n\n  if ( !helpers.validate.isArray( classLabels ) ) {\n    throw Error( 'cross validate: class labels must be an array.' );\n  }\n  if ( classLabels.length < 2 ) {\n    throw Error( 'cross validate: at least 2 class labels are required.' );\n  }\n  labels = classLabels;\n  labelCount = labels.length;\n\n  reset();\n\n  methods.reset = reset;\n  methods.evaluate = evaluate;\n  methods.metrics = metrics;\n\n  return methods;\n}; // cross()\n\n// ### Object Helpers\n\nhelpers.string = Object.create( null );\n\n// Regex for [diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) removal.\nvar rgxDiacritical = /[\\u0300-\\u036f]/g;\n\n/**\n *\n * Normalizes the token's value by converting it to lower case and stripping\n * the diacritical marks (if any).\n *\n * @param {string} str — that needs to be normalized.\n * @return {string} the normalized value.\n * @example\n * normalize( 'Nestlé' );\n * // -> nestle\n*/\nhelpers.string.normalize = function ( str ) {\n  return (\n    str.toLowerCase().normalize( 'NFD' ).replace( rgxDiacritical, '' )\n  );\n}; // normalize()\n\nmodule.exports = helpers;\n","'use strict';\n\n// MODULES //\n\nvar dot = require( 'compute-dot' ),\n\tl2norm = require( 'compute-l2norm' ),\n\tisArray = require( 'validate.io-array' ),\n\tisFunction = require( 'validate.io-function' );\n\n\n// FUNCTIONS //\n\n/**\n* Partially applied function from the right.\n*\n* @private\n* @param {Function} fn - input function\n* @param {number} j - array index\n* @returns {Function} partially applied function\n*/\nfunction partial( fn, j ) {\n\treturn function accessor( d, i ) {\n\t\treturn fn( d, i, j );\n\t};\n}\n\n\n// MAIN //\n\n/**\n* Computes the cosine similarity between two arrays.\n*\n* @param {number[]|Array} x - input array\n* @param {number[]|Array} y - input array\n* @param {Function} [accessor] - accessor function for accessing array values\n* @returns {number|null} cosine similarity or null\n*/\nfunction similarity( x, y, clbk ) {\n\tvar a, b, c;\n\tif ( !isArray( x ) ) {\n\t\tthrow new TypeError( 'cosine-similarity()::invalid input argument. First argument must be an array. Value: `' + x + '`.' );\n\t}\n\tif ( !isArray( y ) ) {\n\t\tthrow new TypeError( 'cosine-similarity()::invalid input argument. Second argument must be an array. Value: `' + y + '`.' );\n\t}\n\tif ( arguments.length > 2 ) {\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'cosine-similarity()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\tif ( x.length !== y.length ) {\n\t\tthrow new Error( 'cosine-similarity()::invalid input argument. Input arrays must have the same length.' );\n\t}\n\tif ( !x.length ) {\n\t\treturn null;\n\t}\n\tif ( clbk ) {\n\t\ta = dot( x, y, clbk );\n\t\tb = l2norm( x, partial( clbk, 0 ) );\n\t\tc = l2norm( y, partial( clbk, 1 ) );\n\t} else {\n\t\ta = dot( x, y );\n\t\tb = l2norm( x );\n\t\tc = l2norm( y );\n\t}\n\treturn a / ( b*c );\n}\n\n\n// EXPORTS //\n\nmodule.exports = similarity;\n","'use strict';\n\n// MODULES //\n\nvar isArray = require( 'validate.io-array' ),\n\tisFunction = require( 'validate.io-function' );\n\n\n// DOT PRODUCT //\n\n/**\n* FUNCTION: dot( x, y[, accessor] )\n*\tComputes the dot product between two arrays.\n*\n* @param {Array} x - input array\n* @param {Array} y - input array\n* @param {Function} [accessor] - accessor function for accessing array values\n* @returns {Number|Null} dot product\n*/\nfunction dot( x, y, clbk ) {\n\tif ( !isArray( x ) ) {\n\t\tthrow new TypeError( 'dot()::invalid input argument. First argument must be an array. Value: `' + x + '`.' );\n\t}\n\tif ( !isArray( y ) ) {\n\t\tthrow new TypeError( 'dot()::invalid input argument. Second argument must be an array. Value: `' + y + '`.' );\n\t}\n\tif ( arguments.length > 2 ) {\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'dot()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\tvar len = x.length,\n\t\tsum = 0,\n\t\ti;\n\n\tif ( len !== y.length ) {\n\t\tthrow new Error( 'dot()::invalid input argument. Arrays must be of equal length.' );\n\t}\n\tif ( !len ) {\n\t\treturn null;\n\t}\n\tif ( clbk ) {\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tsum += clbk( x[ i ], i, 0 ) * clbk( y[ i ], i, 1 );\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tsum += x[ i ] * y[ i ];\n\t\t}\n\t}\n\treturn sum;\n} // end FUNCTION dot()\n\n\n// EXPORTS //\n\nmodule.exports = dot;\n","'use strict';\n\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/\nfunction isArray( value ) {\n\treturn Object.prototype.toString.call( value ) === '[object Array]';\n} // end FUNCTION isArray()\n\n// EXPORTS //\n\nmodule.exports = Array.isArray || isArray;\n","/**\n*\n*\tVALIDATE: function\n*\n*\n*\tDESCRIPTION:\n*\t\t- Validates if a value is a function.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n'use strict';\n\n/**\n* FUNCTION: isFunction( value )\n*\tValidates if a value is a function.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a function\n*/\nfunction isFunction( value ) {\n\treturn ( typeof value === 'function' );\n} // end FUNCTION isFunction()\n\n\n// EXPORTS //\n\nmodule.exports = isFunction;\n","'use strict';\n\n// MODULES //\n\nvar isArray = require( 'validate.io-array' ),\n\tisFunction = require( 'validate.io-function' );\n\n\n// L2NORM //\n\n/**\n* FUNCTION: l2norm( arr[, accessor] )\n*\tCalculates the L2 norm (Euclidean norm) of an array.\n*\n* @param {Array} arr - input array\n* @param {Function} [accessor] - accessor function for accessing array values\n* @returns {Number|Null} L2 norm or null\n*/\nfunction l2norm( arr, clbk ) {\n\tif ( !isArray( arr ) ) {\n\t\tthrow new TypeError( 'l2norm()::invalid input argument. Must provide an array.  Value: `' + arr + '`.' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'l2norm()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\tvar len = arr.length,\n\t\tt = 0,\n\t\ts = 1,\n\t\tr,\n\t\tval,\n\t\tabs,\n\t\ti;\n\n\tif ( !len ) {\n\t\treturn null;\n\t}\n\tif ( clbk ) {\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tval = clbk( arr[ i ], i );\n\t\t\tabs = ( val < 0 ) ? -val : val;\n\t\t\tif ( abs > 0 ) {\n\t\t\t\tif ( abs > t ) {\n\t\t\t\t\tr = t / val;\n\t\t\t\t\ts = 1 + s*r*r;\n\t\t\t\t\tt = abs;\n\t\t\t\t} else {\n\t\t\t\t\tr = val / t;\n\t\t\t\t\ts = s + r*r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tval = arr[ i ];\n\t\t\tabs = ( val < 0 ) ? -val : val;\n\t\t\tif ( abs > 0 ) {\n\t\t\t\tif ( abs > t ) {\n\t\t\t\t\tr = t / val;\n\t\t\t\t\ts = 1 + s*r*r;\n\t\t\t\t\tt = abs;\n\t\t\t\t} else {\n\t\t\t\t\tr = val / t;\n\t\t\t\t\ts = s + r*r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn t * Math.sqrt( s );\n} // end FUNCTION l2norm()\n\n\n// EXPORTS //\n\nmodule.exports = l2norm;\n"],"names":["$3de00a38380ef818$var$helpers","$3de00a38380ef818$var$productReducer","$3de00a38380ef818$var$objectKeys","$3de00a38380ef818$var$objectCreate","$3de00a38380ef818$var$rgxDiacritical","$3f3b3750e38ae9e1$exports","$ff4b8d177131cdf4$exports","Object","create","prev","curr","c","p","cmax","length","pmax","result","push","concat","array","isArray","v","prototype","toString","call","ascending","a","b","descending","ascendingOnKey","descendingOnKey","ascendingOnValue","descendingOnValue","ascendingOn","accessor1","accessor2","descendingOn","pluck","key","limit","k","plucked","i","lim","Array","product","reduce","shuffle","candidate","temp","balance","Math","floor","random","keys","object","isObject","obj","size","values","valueFreq","val","vf","table","f","ak","av","pairs","validate","isFiniteInteger","n","isNaN","isFinite","round","isFiniteNumber","cross","classLabels","cm","precision","recall","fmeasure","labels","labelCount","evaluated","labelsObj","methods","reset","row","j","col","Error","evaluate","truth","guess","metrics","pd","rd","avgPrecision","avgRecall","avgFMeasure","toFixed","details","confusionMatrix","string","normalize","str","toLowerCase","replace"],"version":3,"file":"search.js.map"}